{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Before to start If you don't know anything about glacier processes, explore this great website . If you don't know anything about glacier evolution modeling, you may watch first this video , which gives some basics. OS: IGM was developed in a Linux environment but works on Windows and Mac. Windows user are strongly recommended to use WSL2 for using the GPU and the OGGM shop module. Disclaimer: IGM implements empirical physical laws, with an important amount of approximations (of any kind). Make sure to understand what you do, to explore key parameters, and interpret the results with care. How to start Running IGM consists of running a python script igm_run , which is made of functions of the IGM python package. This documentation will help you to understand the parameters and, set-up your model by listing the modules you need, customize your own modules for your application. First, start with the 10-min video tutorial , or a longer IGS seminar presentation , and/or look at the in-progress IGM technical paper . Then, install an igm python environment on your system and starting with examples . Then, learn how to run IGM with module list and parameter setting (without extra coding), and explore the module documentation . Last, understand the code and write your own module code .","title":"Before to start"},{"location":"#before-to-start","text":"If you don't know anything about glacier processes, explore this great website . If you don't know anything about glacier evolution modeling, you may watch first this video , which gives some basics. OS: IGM was developed in a Linux environment but works on Windows and Mac. Windows user are strongly recommended to use WSL2 for using the GPU and the OGGM shop module. Disclaimer: IGM implements empirical physical laws, with an important amount of approximations (of any kind). Make sure to understand what you do, to explore key parameters, and interpret the results with care.","title":"Before to start"},{"location":"#how-to-start","text":"Running IGM consists of running a python script igm_run , which is made of functions of the IGM python package. This documentation will help you to understand the parameters and, set-up your model by listing the modules you need, customize your own modules for your application. First, start with the 10-min video tutorial , or a longer IGS seminar presentation , and/or look at the in-progress IGM technical paper . Then, install an igm python environment on your system and starting with examples . Then, learn how to run IGM with module list and parameter setting (without extra coding), and explore the module documentation . Last, understand the code and write your own module code .","title":"How to start"},{"location":"About_GPUs/","text":"IGM works fine on CPU for small computational domains (typically individual glaciers). In contrast, GPUs will be very advantageous to treat very large computational grids (typically large networks of glaciers) as IGM naturally takes further benefit from parallelism. Resolution Minimum computational ressource 0.25 K: 256 x 192 pixel CPU 1 K : 1024 x 768 pixel laptop GPU e.g., RTX A4000 4 K : 3840 x 2160 pixel excellent GPU e.g., RTX 4090 To illustrate this, I modeled the ice dynamics and glacier evolution over New Zealand by forcing the mass balance with an ELA oscillating between 1000 and 2000 meters a.s.l. The 1000-year-long simulation took about 1.5 hours on the Nvidia RTX 3090 GPU with a 640x700 km computational domain at 200 meters of resolution (i.e. 3200x3500 grid). The animation can be visualized on this link .","title":"About GPUs"},{"location":"Credits_and_references/","text":"References There is currently an in-progress IGM technical paper that will give you an overview of the physical components, modules, and capabilities of IGM. If you use IGM in publications, make sure to cite one of the following papers and the code version you used. @article{IGM, author = \"Jouvet, Guillaume and Cordonnier, Guillaume and Kim, Byungsoo and L\u00fcthi, Martin and Vieli, Andreas and Aschwanden, Andy\", title = \"Deep learning speeds up ice flow modelling by several orders of magnitude\", DOI = \"10.1017/jog.2021.120\", journal = \"Journal of Glaciology\", year = 2021, pages = \"1\u201314\", publisher = \"Cambridge University Press\" } @article{IGM-inv, author = \"Jouvet, Guillaume\", title = \"Inversion of a Stokes ice flow model emulated by deep learning\", DOI = \"10.1017/jog.2022.41\", journal = \"Journal of Glaciology\", year = \"2022\", pages = \"1--14\", publisher = \"Cambridge University Press\" } @article{IGM-PINN, title={Ice-flow model emulator based on physics-informed deep learning}, author={Jouvet, Guillaume and Cordonnier, Guillaume}, journal={Journal of Glaciology}, pages={1--15}, year={2023}, publisher={Cambridge University Press}, doi={10.1017/jog.2023.73} } Acknowledgements I greatly thank Guillaume Cordonnier for his valuable help with the TensorFlow implementation. The Parallel Ice Sheet Model has greatly inspired the naming of variables, as well as the format of input and output NetCDF files.","title":"Credits and references"},{"location":"Credits_and_references/#references","text":"There is currently an in-progress IGM technical paper that will give you an overview of the physical components, modules, and capabilities of IGM. If you use IGM in publications, make sure to cite one of the following papers and the code version you used. @article{IGM, author = \"Jouvet, Guillaume and Cordonnier, Guillaume and Kim, Byungsoo and L\u00fcthi, Martin and Vieli, Andreas and Aschwanden, Andy\", title = \"Deep learning speeds up ice flow modelling by several orders of magnitude\", DOI = \"10.1017/jog.2021.120\", journal = \"Journal of Glaciology\", year = 2021, pages = \"1\u201314\", publisher = \"Cambridge University Press\" } @article{IGM-inv, author = \"Jouvet, Guillaume\", title = \"Inversion of a Stokes ice flow model emulated by deep learning\", DOI = \"10.1017/jog.2022.41\", journal = \"Journal of Glaciology\", year = \"2022\", pages = \"1--14\", publisher = \"Cambridge University Press\" } @article{IGM-PINN, title={Ice-flow model emulator based on physics-informed deep learning}, author={Jouvet, Guillaume and Cordonnier, Guillaume}, journal={Journal of Glaciology}, pages={1--15}, year={2023}, publisher={Cambridge University Press}, doi={10.1017/jog.2023.73} }","title":"References"},{"location":"Credits_and_references/#acknowledgements","text":"I greatly thank Guillaume Cordonnier for his valuable help with the TensorFlow implementation. The Parallel Ice Sheet Model has greatly inspired the naming of variables, as well as the format of input and output NetCDF files.","title":"Acknowledgements"},{"location":"Custom_Modules/","text":"It is fairly simple to write your own module in a separate python file and include it in the workflow, e.g. to force a climate and/or surface mass balance model specific to an application. For that, one needs to undestand how IGM is coded. Coding structure A closer look at script igm_run.py reveals the following main steps: Load key libraries (tensorflow and igm): Collect defaults, overide from json file, and parse all core and specific module parameters into params , load custom modules, and get the list of all modules in order: Define a state class/dictionnary that contains all the data (e.g. ice thickness) Initialize, update and finalize all model components in given order after placing on '/CPU:0' or '/GPU:0' device. Each module have at least 4 functions defined (some may do nothing, but still need to be defined): a parameter function 'params(parser)' that defines the parameter associated with the module, an initialization function 'initialize(params,state)' that initializes all that needs to be prior to the main time loop, an update function 'update(parser)' that updates the state within the main time loop, a finalize function 'finalize(parser)' that finalizes the module after the time loop. In igm_run , all variables describing the glacier state at a time t are stored in the state object. All these variable are TensorFlow 2.0 Tensors. Using Tensorflow is key to making computationally efficient operations, especially on GPU. Any variables can be accessed/modified via state.nameofthevariable, e.g., ```python state.thk # is the ice thickness variable state.usurf # is the top surface elevation Variables names are summarized [here](https://github.com/jouvetg/igm/wiki/5.-Variables). # Creating own module Similarly to existing IGM ones, a user-defined module my_module can be implemented in a file my_module.py, which will be will automatically loaded when `igm_run` is executed providing `my_module` is listed in any module list parameters. The implementation must have the 4 functions that permits to defined parameters, initializing, updating, and finalizing. For instance, to implementation of the mass balance function 'sinus' with an oscillating ELA, you may create a module 'mysmb' in a file mysmb.py, which update the object state.smb from other fields and parameters: ```python def params(parser): parser.add_argument(\"--meanela\", type=float, default=3000 ) def initialize(params,state): pass def update(params,state): # perturabe the ELA with sinusional signal ELA = ( params.meanela + 750*math.sin((state.t/100)*math.pi) ) # compute smb linear with elevation with 2 acc & abl gradients state.smb = state.usurf - ELA state.smb *= tf.where(state.smb<0, 0.005, 0.009) # cap smb by 2 m/y state.smb = tf.clip_by_value(state.smb, -100, 2) # make sure the smb is not positive outside of the mask to prevent overflow state.smb = tf.where((state.smb<0)|(state.icemask>0.5),state.smb,-10) def finalize(params,state): pass then, it remains to call these new function and add 'mysmb' to the list of modules as parameter. Note that the four functions (params, init, update, finalize) must be defined even if some are not doing anything (just use pass ). You may find coding inspiration / examples looking at the code of IGM modules above. IGM fully relies on TensorFlow 2.0 library for computational efficiency on GPU. All variables (e.g. ice thickness) are TensorFlow tensor objects, which can only be modified using TensorFlow operations. All these operations are vectorial , i.e. they apply simultaneously to all entries of 2D gridded fields, which is key for parallel and efficient execution. This means that one must avoid any sequential operations (typically loop of indices of 2D arrays), and favour TensorFlow (optimized) operations between large arrays (e.g. neural networks). At first sight, a lot of TensorFlow functions look similar to Numpy ones, one can simply do operations by changing numpy to tensorflow, e.g. 'tf.zeros()' instead of 'np.zeros()' with 'import tensorflow as tf' instead of 'import numpy as np'. E.g. Tensorflow operations look like: state.topg = tf.zeros_like(state.usurf) # define Variable Tensor state.smb = tf.where(state.usurf > 4000, 0, state.smb) # Imposes zero mass balance above 4000 m asl. state.usurf = state.topg + state.thk # Update surface topography with new ice thickness state.smb = tf.clip_by_value( (state.usurf - ela)*grad , -100, 2.0 ) # Define linear smb wrt z, with capping value u = tf.concat( [u[:, 0:1], 0.5 * (u[:, :-1] + u[:, 1:]), u[:, -1:]], 1 ) # work on straggered grid In fact, there are two kinds of tensor that are used in IGM. First, \"EagerTensor\" (as shown above) can make many operations, however, we can NOT change specific tensor entries (slicing): tensor = tf.ones((500,300)) tensor = (2*tensor + 200)**2 tensor[1,2] = 5 # WILL NOT WORK As a workaround, one uses \"tf.Variable\" that permits to slice, however, the assignment is slightly different, it can not be done with \"=\", but with the \"assign\" function: tensor = tf.Variable(tf.ones((500,300))) tensor.assign( (2*tensor + 200)**2 ) tensor[1,2].assign( 5 ) # WORKS ! IGM combines both types of tensors, so make sure to identify what is your type, other TF will produce an error. For the best computational efficiency, it is crucial to keep all variables and operations within the TensorFlow framework without using Numpy (to avoid unnecessary transfers between GPU and CPU memory). There is the possibility to generate TensorFlow function using Numpy code, check at this page . The best way to learn how to code with tensorflow within the context of IGM is to explore module codes , or to look at examples . Overriding modules Sometime, it may happen that you would like to bring a minor modification to an existing module. If so, no need to copy/paste the entire module and bring your modification, you may simply define a module with the same name existingmodule.py that contains only the function you would like to modify. All other function will be taken from the orginal module. For instance, this IGM example implements a special seeding strategy for the particle module in user-defined particles.py. Only two functions of the module are changed. Sharing your module If you have developed a module that you believe may be useful to the community and be shared within igm package, read this section carefully. First, give a meaningful name to your module, and try to match the structure of other existing modules for consistency. Please name modulename.py and modulename.md the python and the documentation files, respectively. The parameter list coming at the end of modulename.md in the doc folder will be generated automatically, so you don't need to do it yourself. Please make sure to name all parameters of your module with a 4 letter long keyword that shorten the name of your module. This permits to prevent against conflicts between parameter names of different modules. Once all of this is achieve, you may contact me, or do a pull request.","title":"Custom Modules"},{"location":"Custom_Modules/#coding-structure","text":"A closer look at script igm_run.py reveals the following main steps: Load key libraries (tensorflow and igm): Collect defaults, overide from json file, and parse all core and specific module parameters into params , load custom modules, and get the list of all modules in order: Define a state class/dictionnary that contains all the data (e.g. ice thickness) Initialize, update and finalize all model components in given order after placing on '/CPU:0' or '/GPU:0' device. Each module have at least 4 functions defined (some may do nothing, but still need to be defined): a parameter function 'params(parser)' that defines the parameter associated with the module, an initialization function 'initialize(params,state)' that initializes all that needs to be prior to the main time loop, an update function 'update(parser)' that updates the state within the main time loop, a finalize function 'finalize(parser)' that finalizes the module after the time loop. In igm_run , all variables describing the glacier state at a time t are stored in the state object. All these variable are TensorFlow 2.0 Tensors. Using Tensorflow is key to making computationally efficient operations, especially on GPU. Any variables can be accessed/modified via state.nameofthevariable, e.g., ```python state.thk # is the ice thickness variable state.usurf # is the top surface elevation Variables names are summarized [here](https://github.com/jouvetg/igm/wiki/5.-Variables). # Creating own module Similarly to existing IGM ones, a user-defined module my_module can be implemented in a file my_module.py, which will be will automatically loaded when `igm_run` is executed providing `my_module` is listed in any module list parameters. The implementation must have the 4 functions that permits to defined parameters, initializing, updating, and finalizing. For instance, to implementation of the mass balance function 'sinus' with an oscillating ELA, you may create a module 'mysmb' in a file mysmb.py, which update the object state.smb from other fields and parameters: ```python def params(parser): parser.add_argument(\"--meanela\", type=float, default=3000 ) def initialize(params,state): pass def update(params,state): # perturabe the ELA with sinusional signal ELA = ( params.meanela + 750*math.sin((state.t/100)*math.pi) ) # compute smb linear with elevation with 2 acc & abl gradients state.smb = state.usurf - ELA state.smb *= tf.where(state.smb<0, 0.005, 0.009) # cap smb by 2 m/y state.smb = tf.clip_by_value(state.smb, -100, 2) # make sure the smb is not positive outside of the mask to prevent overflow state.smb = tf.where((state.smb<0)|(state.icemask>0.5),state.smb,-10) def finalize(params,state): pass then, it remains to call these new function and add 'mysmb' to the list of modules as parameter. Note that the four functions (params, init, update, finalize) must be defined even if some are not doing anything (just use pass ). You may find coding inspiration / examples looking at the code of IGM modules above. IGM fully relies on TensorFlow 2.0 library for computational efficiency on GPU. All variables (e.g. ice thickness) are TensorFlow tensor objects, which can only be modified using TensorFlow operations. All these operations are vectorial , i.e. they apply simultaneously to all entries of 2D gridded fields, which is key for parallel and efficient execution. This means that one must avoid any sequential operations (typically loop of indices of 2D arrays), and favour TensorFlow (optimized) operations between large arrays (e.g. neural networks). At first sight, a lot of TensorFlow functions look similar to Numpy ones, one can simply do operations by changing numpy to tensorflow, e.g. 'tf.zeros()' instead of 'np.zeros()' with 'import tensorflow as tf' instead of 'import numpy as np'. E.g. Tensorflow operations look like: state.topg = tf.zeros_like(state.usurf) # define Variable Tensor state.smb = tf.where(state.usurf > 4000, 0, state.smb) # Imposes zero mass balance above 4000 m asl. state.usurf = state.topg + state.thk # Update surface topography with new ice thickness state.smb = tf.clip_by_value( (state.usurf - ela)*grad , -100, 2.0 ) # Define linear smb wrt z, with capping value u = tf.concat( [u[:, 0:1], 0.5 * (u[:, :-1] + u[:, 1:]), u[:, -1:]], 1 ) # work on straggered grid In fact, there are two kinds of tensor that are used in IGM. First, \"EagerTensor\" (as shown above) can make many operations, however, we can NOT change specific tensor entries (slicing): tensor = tf.ones((500,300)) tensor = (2*tensor + 200)**2 tensor[1,2] = 5 # WILL NOT WORK As a workaround, one uses \"tf.Variable\" that permits to slice, however, the assignment is slightly different, it can not be done with \"=\", but with the \"assign\" function: tensor = tf.Variable(tf.ones((500,300))) tensor.assign( (2*tensor + 200)**2 ) tensor[1,2].assign( 5 ) # WORKS ! IGM combines both types of tensors, so make sure to identify what is your type, other TF will produce an error. For the best computational efficiency, it is crucial to keep all variables and operations within the TensorFlow framework without using Numpy (to avoid unnecessary transfers between GPU and CPU memory). There is the possibility to generate TensorFlow function using Numpy code, check at this page . The best way to learn how to code with tensorflow within the context of IGM is to explore module codes , or to look at examples .","title":"Coding structure"},{"location":"Custom_Modules/#overriding-modules","text":"Sometime, it may happen that you would like to bring a minor modification to an existing module. If so, no need to copy/paste the entire module and bring your modification, you may simply define a module with the same name existingmodule.py that contains only the function you would like to modify. All other function will be taken from the orginal module. For instance, this IGM example implements a special seeding strategy for the particle module in user-defined particles.py. Only two functions of the module are changed.","title":"Overriding modules"},{"location":"Custom_Modules/#sharing-your-module","text":"If you have developed a module that you believe may be useful to the community and be shared within igm package, read this section carefully. First, give a meaningful name to your module, and try to match the structure of other existing modules for consistency. Please name modulename.py and modulename.md the python and the documentation files, respectively. The parameter list coming at the end of modulename.md in the doc folder will be generated automatically, so you don't need to do it yourself. Please make sure to name all parameters of your module with a 4 letter long keyword that shorten the name of your module. This permits to prevent against conflicts between parameter names of different modules. Once all of this is achieve, you may contact me, or do a pull request.","title":"Sharing your module"},{"location":"Examples/","text":"The best and quickest way to get to know IGM is to run given examples. Having IGM installed on your machine, you can simply run igm_run in a folder that contains the following parameter file params.json : { \"modules_preproc\": [\"oggm_shop\"], \"modules_process\": [\"clim_oggm\", \"smb_oggm\", \"iceflow\", \"time\", \"thk\" ], \"modules_postproc\": [\"write_ncdf\", \"plot2d\", \"print_info\", \"print_comp\"], \"clim_oggm_clim_trend_array\": [ [\"time\", \"delta_temp\", \"prec_scal\"], [ 1900, 0.0, 1.0], [ 2020, 0.0, 1.0], [ 2100, 4.0, 1.0] ], \"oggm_RGI_ID\": \"RGI60-11.01450\", \"time_start\": 1800.0, \"time_end\": 2100.0, \"plt2d_live\": true, \"iflo_init_slidingco\": 0.25 } You may run other ready-to-use examples in the folder test/examples/ in the develop version, which contains input data and parameter files. To run the example, just go in each folder and run igm_run there. You have the following examples available: quick-demo provides a set-up to model any glacier given an RGI ID, with a OGGM-based climate forcing and SMB. quick-demo-mysmb is like quick-demo but wirh a own user-defined SMB module / parametrization. aletsch-basic provides a simple set-up for an advance-retreat simulation of the largest glacier of the European Alps -- Aletsch Glacier, Switzerland -- using a simple parametrization of the mass balance based on time-varying Equilibrium Line Altitudes (ELA). aletsch-1880-2100 gives the set-up to reproduce the simulations of the Great Aletsch Glacier (Switzerland) in the past and in the future based on the CH2018 climate scenarios and an accumulation/melt model. aletsch-invert and rhone-invert gives an example of data assimilation with IGM (Warning: inverse modelling requires tuning parameters for each glacier). rhone-invert is the most advanced/recent setting. paleo-alps consists of a simple set-up to run a paleo glacier model in the European Alps in paleo times with different catchments (lyon, ticino, rhine, linth glaciers) with IGM around the last glacial maximum (LGM, about 24 BP in the Alps). synthetic permits to make simple numerical experiments with simple synthetic bedrock topographies.","title":"Examples"},{"location":"FAQ/","text":"Ice is stuck on the border of the domain (no fluxes), what can I do? Set parameter exclude_borders_from_iceflow to True I see some numerical artifacts (e.g. waves) occurring when modeling glacier evolution, what can I do? Reduce the CFL parameter How to create/modify NetCDF files? There are many ways to prepare NetCDF files (matlab, python, GIS tools, ...). The NCO toolkit permits easy operations in command lines, e.g. ncks -x -v thk file.nc file.nc # this removes the variable 'thk' from file.nc ncks -v usurf file.nc file.nc # this extracts the variable usurf from file.nc ncap2 -h -O -s 'thk=0*thk' file.nc file.nc # this does operations on file.nc, here force zero thk ncrename -v apc,strflowctrl file.nc # this renames varible apc to strflowctrl in file.nc oggm_shop produces error on windows This is expected, OGGM is not supported on windows, however, modifying the tarfile.py file at line 2677 from name == member_name to name.replace(os.sep, '/') == member_name seems to fix the issue on Windows. Thanks Alexi Morin for proposing this workaround.","title":"FAQ"},{"location":"Installation/","text":"IGM is a Python package, which works on any OS on CPU (not computationally efficient, but fine for small applications like individual glaciers), GPU (the most computationally efficient way, especially relevant for large-scale and high-resolution applications). IGM can be installed with the the main version for stable application (the latest available tag), not all modules, the development version to get the latest feature with all modules (at the possible price of unrevealed bugs). Both versions are now on the same (main) branch. IGM is rapidly changing, keep track of updates on the release page for the tagged versions or/and on this page for the development version. Note that the igm package installs most of dependent packages, but not all. For using some post-processing modules, the user has to install additional packages (e.g., mayavi, plotly, ect.). We first describe the installation in Linux (the preferred OS), and then on Windows and Mac. Linux Install NVIDIA drivers If you aim to use only the CPU or already get an output from nvidia-smi , you can skip this step. # get the latest libraries from apt sudo apt update sudo apt upgrade # choose which driver version is compatible with your GPU device (in this case 510) sudo apt install nvidia-driver-510 nvidia-dkms-510 sudo reboot # you wont see the changes until after you reboot After rebooting, you can check your driver version with the command watch -d -n 0.5 nvidia-smi should give you live information on your GPU device. Install anaconda and create a virtual environment (strongly recommended) with conda or venv: # install anaconda wget https://repo.anaconda.com/archive/Anaconda3-2023.09-0-Linux-x86_64.sh bash Anaconda3-2023.09-0-Linux-x86_64.sh # create new environment conda create --name igm python=3.10 # activate environment to install IGM conda activate igm or # create igm venv environment python3.10 -m venv igm # activate environment to install IGM source igm/bin/activate Install IGM For simple usage, you can install the latest IGM stable version and its dependencies from the Pypi as follows: pip install igm_model OR for using all and recent features, you can install the IGM development version from the github repository as follows: git clone https://github.com/jouvetg/igm.git cd igm pip install -e . After that, you may run any example ( igm_run ). As IGM is being updated often, make sure you have the latest version, you may run git pull Windows Tensorflow does not allow us to run IGM on GPU directly on Windows, and the module oggm_shop does not work on windows. Therefore, we recommend windows-user to install WSL2-ubuntu, which provides a linux/ubuntu terminal. WSL2 terminal can be nicely linked with VS code (with an extension). First, install WSL2-ubuntu wsl --install Ubuntu-22.04 sudo apt update sudo apt upgrade and then, install the NVIDIA drivers if not done (if you get no output from nvidia-smi ), and if you wish to use the GPU. The rest -- installation of conda or venv environment and the installation of IGM -- are the same as above on Linux. Mac IGM core library native Tensorflow is not supported on Mac for GPU usage. Instead, a \"Tensorflow for Mac\", called tensorflow-metal , was developed as workaround. To install IGM on Mac, you may follow the linux workflow, however, you will need to change in setup.py tensorflow by tensorflow-macos. Here is a working procedure (tested on MacBook Pro M2) -- still we recommend using a virtual environment such as conda or venv as on linux: git clone -b develop https://github.com/jouvetg/igm cd igm You need to edit \"install_requires=[...]\" in the file \"setup.py\": To use only the CPUs: tensorflow-macos==2.14.0 To use the GPUs: tensorflow-macos==2.14.0, tensorflow-metal, and then pip install -e . Troubleshooting Main source of issues are linked to Tensorflow and the use of GPU. Hopefully, the installation is significantly easier since tensorflow 2.14.0 since it can install all necessary GPU/cuda dependent packages with the right version automatically. Note that to ensure smooth usage of GPU with cuda and tensorflow libraries , one has to make sure that i) cuda ii) cudnn iii) tensorflow are compatible , and your Nvidia driver is compatible with the version of cuda. Such incompatibility is the most common source of issue. For instance, it is possible do install tensorflow-2.12.0 by setting tensorflow==2.12.0 in the setup.py and conda install -c conda-forge cudatoolkit=11.8.0 pip install nvidia-cudnn-cu11==8.6.0.163 mkdir -p ${CONDA_PREFIX}/etc/conda/activate.d D=${CONDA_PREFIX}/etc/conda/activate.d/env.sh echo 'export PYTHONNOUSERSITE=1' >> $D echo 'export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:${CONDA_PREFIX}/lib' >> $D echo 'export CUDNN_PATH=$(dirname $(python -c \"import nvidia.cudnn;print(nvidia.cudnn.__file__)\"))' >> $D echo 'export LD_LIBRARY_PATH=$CONDA_PREFIX/lib/:$CUDNN_PATH/lib:$LD_LIBRARY_PATH' >> $D","title":"Installation"},{"location":"Installation/#linux","text":"Install NVIDIA drivers If you aim to use only the CPU or already get an output from nvidia-smi , you can skip this step. # get the latest libraries from apt sudo apt update sudo apt upgrade # choose which driver version is compatible with your GPU device (in this case 510) sudo apt install nvidia-driver-510 nvidia-dkms-510 sudo reboot # you wont see the changes until after you reboot After rebooting, you can check your driver version with the command watch -d -n 0.5 nvidia-smi should give you live information on your GPU device. Install anaconda and create a virtual environment (strongly recommended) with conda or venv: # install anaconda wget https://repo.anaconda.com/archive/Anaconda3-2023.09-0-Linux-x86_64.sh bash Anaconda3-2023.09-0-Linux-x86_64.sh # create new environment conda create --name igm python=3.10 # activate environment to install IGM conda activate igm or # create igm venv environment python3.10 -m venv igm # activate environment to install IGM source igm/bin/activate Install IGM For simple usage, you can install the latest IGM stable version and its dependencies from the Pypi as follows: pip install igm_model OR for using all and recent features, you can install the IGM development version from the github repository as follows: git clone https://github.com/jouvetg/igm.git cd igm pip install -e . After that, you may run any example ( igm_run ). As IGM is being updated often, make sure you have the latest version, you may run git pull","title":"Linux"},{"location":"Installation/#windows","text":"Tensorflow does not allow us to run IGM on GPU directly on Windows, and the module oggm_shop does not work on windows. Therefore, we recommend windows-user to install WSL2-ubuntu, which provides a linux/ubuntu terminal. WSL2 terminal can be nicely linked with VS code (with an extension). First, install WSL2-ubuntu wsl --install Ubuntu-22.04 sudo apt update sudo apt upgrade and then, install the NVIDIA drivers if not done (if you get no output from nvidia-smi ), and if you wish to use the GPU. The rest -- installation of conda or venv environment and the installation of IGM -- are the same as above on Linux.","title":"Windows"},{"location":"Installation/#mac","text":"IGM core library native Tensorflow is not supported on Mac for GPU usage. Instead, a \"Tensorflow for Mac\", called tensorflow-metal , was developed as workaround. To install IGM on Mac, you may follow the linux workflow, however, you will need to change in setup.py tensorflow by tensorflow-macos. Here is a working procedure (tested on MacBook Pro M2) -- still we recommend using a virtual environment such as conda or venv as on linux: git clone -b develop https://github.com/jouvetg/igm cd igm You need to edit \"install_requires=[...]\" in the file \"setup.py\": To use only the CPUs: tensorflow-macos==2.14.0 To use the GPUs: tensorflow-macos==2.14.0, tensorflow-metal, and then pip install -e .","title":"Mac"},{"location":"Installation/#troubleshooting","text":"Main source of issues are linked to Tensorflow and the use of GPU. Hopefully, the installation is significantly easier since tensorflow 2.14.0 since it can install all necessary GPU/cuda dependent packages with the right version automatically. Note that to ensure smooth usage of GPU with cuda and tensorflow libraries , one has to make sure that i) cuda ii) cudnn iii) tensorflow are compatible , and your Nvidia driver is compatible with the version of cuda. Such incompatibility is the most common source of issue. For instance, it is possible do install tensorflow-2.12.0 by setting tensorflow==2.12.0 in the setup.py and conda install -c conda-forge cudatoolkit=11.8.0 pip install nvidia-cudnn-cu11==8.6.0.163 mkdir -p ${CONDA_PREFIX}/etc/conda/activate.d D=${CONDA_PREFIX}/etc/conda/activate.d/env.sh echo 'export PYTHONNOUSERSITE=1' >> $D echo 'export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:${CONDA_PREFIX}/lib' >> $D echo 'export CUDNN_PATH=$(dirname $(python -c \"import nvidia.cudnn;print(nvidia.cudnn.__file__)\"))' >> $D echo 'export LD_LIBRARY_PATH=$CONDA_PREFIX/lib/:$CUDNN_PATH/lib:$LD_LIBRARY_PATH' >> $D","title":"Troubleshooting"},{"location":"Running/","text":"Assuming you have installed the right igm environment, the glacier evolution model IGM can be run via the command igm_run : define igm_run --RGI-ID RGI60-11.01450 --time_start 2023 --time_end 2100 where parameters are given in command line as above or in a file params.json (recommended) like { \"modules_preproc\": [\"oggm_shop\"], \"modules_process\": [\"smb_simple\",\"iceflow\",\"time\",\"thk\"], \"modules_postproc\": [\"write_ncdf\",\"plot2d\",\"print_info\",\"print_comp\"], \"oggm_RGI_ID\": \"RGI60-11.01238\", \"time_start\": 2023.0, \"time_end\": 2100.0 } and igm_run.py is a short python script located in the root directory that perform the following steps (check the code for more details): collect parameters into params object, including the ordered list of modules modules , define a state object that contains all the data (e.g. ice thickness), initialize all model components in turn, update all model components in turn within a time loop from start to end times, finalize all model components in turn. Therefore running IGM requires to define parameters params , which includes first-of-all the list of wished IGM modules. IGM can also take the parameter file as input as follows: igm_run --param_file params1.json Parameters ( params , full list ) IGM has a few core parameters: short long default help --param_file params.json Parameter file --modules_preproc [\"prepare_data\"] List of pre-processing modules --modules_process [\"iceflow\",\"time\",\"thk\"] List of processing modules --modules_postproc [\"write_ncdf\",\"print_info\"] List of post-processing modules --logging False Activate the logging and many other module-specific parameters, see the full list of parameters or the module documentation for the meaning and default values of the parameters of each module. Parameters passed in command line override those passed in the jon parameter file, which override the default IGM parameters. Modules ( modules ) IGM is organized module-wise. Each user must pick a sequence of existing pre-processing , processing , post-processing and/or user-made modules she/he wishes to have for her/his application (check at the module documentation . Each module implements all least 4 functions for module-specific parameter definition, initialization, update and finalization, which are called by igm_run . This section helps to chose the appropriate module. First one needs pre-processing modules : For modelling individual present-day glacier, the best is to use the OGGM-based prepare_data module, which take care of downloading all the gridded data appropriatly. In that case, the modules_preproc in the json parameter file look like: \"modules_preproc\": [\"oggm_shop\"], Alternatively to module oggm_shop , one may load the data directly NetCDF file (with module load_ncdf ), tif file (with module load_tif ) or from analytical formula for synthetic glacier tests ( synthetic ). Optionally the additional module optimize permits to do data assimilation seeking for ice thickness distribution, ice flow parameters that yield the best fit with data (e.g. surface ice speeds). In that case, the `modules_preproc in the json parameter file look like: \"modules_preproc\": [\"prepare_data\",\"optimize\"], Second one needs to define processing modules: The minimum to have as processing is the combination of ice flow (module iceflow ), ice thickness (module thk ), and time step (module time ): \"modules_process\": [\"iceflow\"\",\"time\",\"thk\"], However, it sounds reasonable to add at least a surface mass balance module (e.g. smb_simple ), and other components we like to have (e.g. computation of vertical velocity, particle trajectory, climate, enthalpy, ...) making sure to respect a logical order, i.e., \"modules_process\": [\"smb_simple\",\"iceflow\",\"time\",\"thk\",\"vert_flow\",\"particles\"], Then, one needs post-processing modules to output the results of the model, e.g. this line will permit to write model output in NetCDF files, make 2D plots, print basic informatinN (e.g. ice volume), and produce a nice 3D animation of the run at the end: \"modules_postproc\": [ \"write_ncdf\", \"plot2d\", \"print_info\", \"anim_mayavi\" ] Lastly, one often needs to customize the code for specific applications. This is easy to do so with IGM, e.g. for imposing own climate forcing, defining own surface mass balance, ... For that purpose, implement your module in a separate file my_mod.py, and add it to the workflow \"modules_process\": [\"smb_simple\",\"iceflow\",\"time\",\"thk\",\"my_mod\"], then, the module will be automatically loaded by igm_run when being executed.","title":"Running IGM"},{"location":"Running/#parameters-params-full-list","text":"IGM has a few core parameters: short long default help --param_file params.json Parameter file --modules_preproc [\"prepare_data\"] List of pre-processing modules --modules_process [\"iceflow\",\"time\",\"thk\"] List of processing modules --modules_postproc [\"write_ncdf\",\"print_info\"] List of post-processing modules --logging False Activate the logging and many other module-specific parameters, see the full list of parameters or the module documentation for the meaning and default values of the parameters of each module. Parameters passed in command line override those passed in the jon parameter file, which override the default IGM parameters.","title":"Parameters (params, full list)"},{"location":"Running/#modules-modules","text":"IGM is organized module-wise. Each user must pick a sequence of existing pre-processing , processing , post-processing and/or user-made modules she/he wishes to have for her/his application (check at the module documentation . Each module implements all least 4 functions for module-specific parameter definition, initialization, update and finalization, which are called by igm_run . This section helps to chose the appropriate module. First one needs pre-processing modules : For modelling individual present-day glacier, the best is to use the OGGM-based prepare_data module, which take care of downloading all the gridded data appropriatly. In that case, the modules_preproc in the json parameter file look like: \"modules_preproc\": [\"oggm_shop\"], Alternatively to module oggm_shop , one may load the data directly NetCDF file (with module load_ncdf ), tif file (with module load_tif ) or from analytical formula for synthetic glacier tests ( synthetic ). Optionally the additional module optimize permits to do data assimilation seeking for ice thickness distribution, ice flow parameters that yield the best fit with data (e.g. surface ice speeds). In that case, the `modules_preproc in the json parameter file look like: \"modules_preproc\": [\"prepare_data\",\"optimize\"], Second one needs to define processing modules: The minimum to have as processing is the combination of ice flow (module iceflow ), ice thickness (module thk ), and time step (module time ): \"modules_process\": [\"iceflow\"\",\"time\",\"thk\"], However, it sounds reasonable to add at least a surface mass balance module (e.g. smb_simple ), and other components we like to have (e.g. computation of vertical velocity, particle trajectory, climate, enthalpy, ...) making sure to respect a logical order, i.e., \"modules_process\": [\"smb_simple\",\"iceflow\",\"time\",\"thk\",\"vert_flow\",\"particles\"], Then, one needs post-processing modules to output the results of the model, e.g. this line will permit to write model output in NetCDF files, make 2D plots, print basic informatinN (e.g. ice volume), and produce a nice 3D animation of the run at the end: \"modules_postproc\": [ \"write_ncdf\", \"plot2d\", \"print_info\", \"anim_mayavi\" ] Lastly, one often needs to customize the code for specific applications. This is easy to do so with IGM, e.g. for imposing own climate forcing, defining own surface mass balance, ... For that purpose, implement your module in a separate file my_mod.py, and add it to the workflow \"modules_process\": [\"smb_simple\",\"iceflow\",\"time\",\"thk\",\"my_mod\"], then, the module will be automatically loaded by igm_run when being executed.","title":"Modules (modules)"},{"location":"Variables/","text":"Whenever this is possible, IGM adopts name convention of PISM . Here is a minimal list of key variables: Variable names Shape Description Unit t () Time variable (scalar) y dt () Time step (scalar) y x,y (nx) Coordinates vectors m thk (ny) Ice thickness m topg (ny,nx) Basal topography (or bedrock) m usurf (ny,nx) Surface topography m smb (ny,nx) Surface Mass Balance m/y ice-eq ubar (ny,nx) x- depth-average velocity of ice m/y vbar (ny,nx) y- depth-average velocity of ice m/y U (nz,ny,nx) x-horiz. 3D velocity field of ice m/y V (nz,ny,nx) y-horiz. 3D velocity field of ice m/y W (nz,ny,nx) z-vert. 3D velocity field of ice m/y arrhenius (ny,nx) Arrhenius Factor MPa^(-3) y^(-1) slidingco (ny,nx) Sliding Coefficient MPa m^(-1/3) y^(-1/3) divflux (ny,nx) Divergence of the flux m/y icemask (ny,nx) Mask to restrict the smb comp. - dtopgdt (ny,nx) Erosion rate m/y xpos,ypos (nb particles) x,y position of particles m rhpos (nb particles) rel. pos of particles in ice column m air_temp (nt,ny,nx) seasonal air temperature 2 m above ground \u00b0C precipitation (nt,ny,nx) seasonal precipitation (water eq) kg m^(-2) y^(-1)","title":"Variables"},{"location":"modules/anim_mayavi/","text":"IGM module anim_3d_from_ncdf_ex Description: This IGM modules makes a 3D animated plot using from the NetCDF output (default output.nc) file produced by module write_ncdf . It only implements the 'finalize' function, the rest ('initialize', 'update') doing nothing. This module depends on the mayavi and pyqt5 libraryies, which are not included in the original igm package. Therefore, you need to install it in your python environent: pip install mayavi pyqt5 Warning: It seems that this module work only with Python <= 3.10","title":"anim_mayavi"},{"location":"modules/anim_mayavi/#igm-module-anim_3d_from_ncdf_ex","text":"","title":"IGM module anim_3d_from_ncdf_ex"},{"location":"modules/anim_mayavi/#description","text":"This IGM modules makes a 3D animated plot using from the NetCDF output (default output.nc) file produced by module write_ncdf . It only implements the 'finalize' function, the rest ('initialize', 'update') doing nothing. This module depends on the mayavi and pyqt5 libraryies, which are not included in the original igm package. Therefore, you need to install it in your python environent: pip install mayavi pyqt5 Warning: It seems that this module work only with Python <= 3.10","title":"Description:"},{"location":"modules/anim_plotly/","text":"IGM module anim_plotly Description: This module permits an interactive 3D vizualization of IGM results reading the NetCDF file produced by module write_ncdf based on libraries dash and plotly . It creates a dash app that can be accessed via a browser (the adress printed in the console is usually http://127.0.0.1:8050/). The app shows a 3D plot of the glacier's surface on top of the surrounding bedrock. The surface color shows either the ice thickness, the velocity magnitude of the surface or the surface mass balance. Variables can be chosen in the dropdown menu. The app also includes a slider to navigate the different time steps of the glacier simulation. This module depends on the dash and plotly library. Therefore, you need to install it in your python environent: pip install dash plotly This module was implemented by Oskar Herrmann .","title":"anim_plotly"},{"location":"modules/anim_plotly/#igm-module-anim_plotly","text":"","title":"IGM module anim_plotly"},{"location":"modules/anim_plotly/#description","text":"This module permits an interactive 3D vizualization of IGM results reading the NetCDF file produced by module write_ncdf based on libraries dash and plotly . It creates a dash app that can be accessed via a browser (the adress printed in the console is usually http://127.0.0.1:8050/). The app shows a 3D plot of the glacier's surface on top of the surrounding bedrock. The surface color shows either the ice thickness, the velocity magnitude of the surface or the surface mass balance. Variables can be chosen in the dropdown menu. The app also includes a slider to navigate the different time steps of the glacier simulation. This module depends on the dash and plotly library. Therefore, you need to install it in your python environent: pip install dash plotly This module was implemented by Oskar Herrmann .","title":"Description:"},{"location":"modules/anim_video/","text":"IGM module `anim_video`` Description: This IGM module makes an animated mp4 video of ice thickness over time from the NetCDF output (default output.nc) file produced by module write_ncdf . It only implements the 'finalize' function, the rest ('initialize', 'update') doing nothing. This module depends on xarray library.","title":"anim_video"},{"location":"modules/anim_video/#igm-module-anim_video","text":"","title":"IGM module `anim_video``"},{"location":"modules/anim_video/#description","text":"This IGM module makes an animated mp4 video of ice thickness over time from the NetCDF output (default output.nc) file produced by module write_ncdf . It only implements the 'finalize' function, the rest ('initialize', 'update') doing nothing. This module depends on xarray library.","title":"Description:"},{"location":"modules/avalanche/","text":"IGM avalanche module Description: This IGM module permits to model redistribution of snow due to avalanches. This routine move ice/snow downslope until the ice surface is everywhere at angle of repose. This function was adapted from Mark Kessler's GC2D program and implemented in IGM by J\u00fcrgen Mey with support from Guillaume Jouvet.","title":"avalanche"},{"location":"modules/avalanche/#igm-avalanche-module","text":"","title":"IGM avalanche module"},{"location":"modules/avalanche/#description","text":"This IGM module permits to model redistribution of snow due to avalanches. This routine move ice/snow downslope until the ice surface is everywhere at angle of repose. This function was adapted from Mark Kessler's GC2D program and implemented in IGM by J\u00fcrgen Mey with support from Guillaume Jouvet.","title":"Description:"},{"location":"modules/clim_oggm/","text":"IGM clim_oggm module Description: Module clim_oggm reads monthly time series of historical GSWP3_W5E5 climate data collected by the oggm_shop module, and generates monthly 2D raster fields of corrected precipitation, mean temperature, and temperature variability. To achieve this, we first apply a multiplicative correction factor for precipitation (parameter prcp_fac ) and a biais correction for temperature (parameter temp_bias ). Then, the module extrapolates temperature data to the entire glacier surface using a reference height and a constant lapse rate (parameter temp_default_gradient ). In constrast, the point-wise data for precipitation and temperature variablity are extended to the entire domain without further correction. Module oggm_shop provides all calibrated parameters. The resulting fields are intended to be used to force the surface mass balance or enthalpy models. In addition, this module can generate climate outside the time frame of available data. To that aim, we define a reference period with parameter clim_oggm_ref_period to pick randomly years within this interval (usually taken to be a climate-neutral period), and apply a biais in temperature and a scaling of precipitation. These parameters may be given in file (file name given in clim_oggm_file parameter), which look like this (this example gives an linear increase of temperature of 4 degrees by the end of 2100 (with respect to the period 1960-1990): time delta_temp prec_scal 1900 0.0 1.0 2020 0.0 1.0 2100 4.0 1.0 or directly as parameter in the config params.json file: \"clim_oggm_clim_trend_array\": [ [\"time\", \"delta_temp\", \"prec_scal\"], [ 1900, 0.0, 1.0], [ 2020, 0.0, 1.0], [ 2100, 4.0, 1.0] ], If parameter clim_oggm_clim_trend_array is set to empty list [] , then it will read the file clim_oggm_file , otherwise it read the array clim_oggm_clim_trend_array (which is here in fact a list of list).","title":"clim_oggm"},{"location":"modules/clim_oggm/#igm-clim_oggm-module","text":"","title":"IGM clim_oggm module"},{"location":"modules/clim_oggm/#description","text":"Module clim_oggm reads monthly time series of historical GSWP3_W5E5 climate data collected by the oggm_shop module, and generates monthly 2D raster fields of corrected precipitation, mean temperature, and temperature variability. To achieve this, we first apply a multiplicative correction factor for precipitation (parameter prcp_fac ) and a biais correction for temperature (parameter temp_bias ). Then, the module extrapolates temperature data to the entire glacier surface using a reference height and a constant lapse rate (parameter temp_default_gradient ). In constrast, the point-wise data for precipitation and temperature variablity are extended to the entire domain without further correction. Module oggm_shop provides all calibrated parameters. The resulting fields are intended to be used to force the surface mass balance or enthalpy models. In addition, this module can generate climate outside the time frame of available data. To that aim, we define a reference period with parameter clim_oggm_ref_period to pick randomly years within this interval (usually taken to be a climate-neutral period), and apply a biais in temperature and a scaling of precipitation. These parameters may be given in file (file name given in clim_oggm_file parameter), which look like this (this example gives an linear increase of temperature of 4 degrees by the end of 2100 (with respect to the period 1960-1990): time delta_temp prec_scal 1900 0.0 1.0 2020 0.0 1.0 2100 4.0 1.0 or directly as parameter in the config params.json file: \"clim_oggm_clim_trend_array\": [ [\"time\", \"delta_temp\", \"prec_scal\"], [ 1900, 0.0, 1.0], [ 2020, 0.0, 1.0], [ 2100, 4.0, 1.0] ], If parameter clim_oggm_clim_trend_array is set to empty list [] , then it will read the file clim_oggm_file , otherwise it read the array clim_oggm_clim_trend_array (which is here in fact a list of list).","title":"Description:"},{"location":"modules/enthalpy/","text":"IGM enthalpy module Warning: this rather complex module was not much tested so far, use it with care! Description: This IGM module models the ice enthalpy, which permits to jointly model the ice temperature, as well as the water content created when the temperature hits the pressure melting points, and therefore energy conservation, which is not the case when modelling the sole temperature variable. The model is described in (Aschwanden and al, JOG, 2012) . Here, we used a simplified version largely inspired from the one implemented in PISM . Other references that have helped are (Kleiner and al, TC, 2015) and (Wang and al, 2020) . Model: Ice flow Here we only quickly sketch the components of the ice dynamical modelling necessary for modeling the Enthalpy. Ice is assumed to be a Non Newtonian fluid, gouverned by Glen's flow law: $$ \\tau = A^{-1/n} | D({\\bf u}) |^{1/n-1} D({\\bf u}), $$ where $D({\\bf U})$ and $\\tau$ are the strain rate and deviatoric stress tensor, respectively. While a no-stress condition is applied on the top surface, we assume that the basal shear stress $\\tau_b$ and the sliding velocity $u_b$ are linked by Weertmann power law at the glacier bed interface: $$ \\tau_b = - c | u_b |^{m-1} u_b, $$ where $c=\\tau_c u_{th}^{-m}$ (unit: $Mpa \\; m^{-m} \\; y^m$), $\\tau_c$ being the yield stress and $u_{th}$ being a parameter homegenous to ice velocity. This formalism is taken from PISM. (Note that originally, IGM had $c^{-m}$ instead of $c$ above as \"slidingco\" with $u_{th}=1$. The newest runs under parameters \"new_sliding_param\", and $c$ has unit $MPa \\; m^{-m} \\; y^m$) Enthalpy The Enthalpy $E$ is a 3D variable defined everywhere in the ice as a function of the temperature $T$ and the water content $\\omega$: $$ \\begin{align} E(T, \\omega,p) = \\left{ \\begin{array}{ll} c_i (T- T_{\\rm ref}), & {\\rm if } \\; T < T_{\\rm pmp} , \\ E_{\\rm pmp} + L \\omega, & {\\rm if } \\; T = T_{\\rm pmp} \\; {\\rm and } \\; 0 \\le \\omega, \\end{array} \\right. \\end{align} $$ where $c_i$ is the heat capacity, $T_{ref}$ is the reference temperature, $T_{\\rm pmp} = T_{\\rm pmp}(p) = T_0 - \\beta p$ is the temperature pressure-melting point of ice, $E_{\\rm pmp}(p)$ is the enthalpy pressure-melting point of ice defined as $$ E_{\\rm pmp}(p) = c_i (T_{\\rm pmp}(p) - T_{\\rm ref}), $$ where $L$ is the latent heat of fusion. According to the above defintion of enthalpy, we have two possible modes: i) the ice is cold, i.e. below the melting point, and the Enthalpy is simply proportional to the temperature minus a reference temperature ii) the ice is temperate and the Enthalpy continue to grow, the additional component $L \\omega$ corresponding to the creation of water content by energy transfer. Therefore, it is straightforward to deduce $E$ from $T$ and $\\omega$. The enthalpy model consists of the following advection-diffusion equation (the horizontal diffusion being neglected): $$ \\begin{align} & \\rho_i \\left( \\frac{\\partial E}{ \\partial t} + u_x \\frac{\\partial E}{ \\partial x} + u_y \\frac{\\partial E}{ \\partial y} + u_z \\frac{\\partial E}{ \\partial z} \\right) - \\frac{\\partial }{\\partial z} \\left( K_{c,t} \\frac{\\partial E}{ \\partial z} \\right) = \\phi - \\rho_w L D_w(\\omega), \\end{align} $$ where $\\rho_i$ is the ice density, $K_{c,t}$ equals $K_c = k_i/c_i$ if the ice is cold ($E<E_{pmp}$) or $K_t = \\epsilon k_i/c_i$ otherwise, $\\phi$ is the strain heating defined by (using Glen's flow law) $$ \\phi = D({\\bf U}) \\tau = A^{-1/n} | D({\\bf u}) |^{1+1/n}, $$ where $D({\\bf U})$ and $\\tau$ are the strain rate and deviatoric stress tensor, respectively. The last source term $- \\rho_w L D_w(\\omega)$ permits to remove the water in temperate ice $D_w(\\omega)$ being a drainage function ((Greve, 1997) and (Aschwanden et al., 2012)). At the top ice surface, the enthalpy equation is constrained by the surface temperature (or equivalently the Enthalpy) provided by the climate forcing (Dirichlet condition). At the glacier bed, boundary conditions for the enthalpy equation are multiple ( (Aschwanden and al, JOG, 2012) , (Kleiner and al, TC, 2015) and (Wang and al, 2020) .) $K_{c} \\frac{\\partial E}{ \\partial z} = Q_{\\rm geo} + Q_{\\rm fh}$ if $E_b<E_{\\rm pmp}$ and $H_w = 0$, (cold base, dry) $ E_b = E_{\\rm pmp} $ if $E_b 0$, (cold base, wet) $ E_b = E_{\\rm pmp} $ if $E_b \\ge E_{\\rm pmp}$ and $W_{till}> 0$, zero temperate basal layer, (temperate base, cold ice) $ K_{t} \\frac{\\partial E}{ \\partial z} = 0$ if $E_b \\ge E_{\\rm pmp}$ and $W_{till} > 0$, non-zero temperate basal layer, (temperate base, temp. ice) where $H_t$ is the height of the temperate basal layer, $Q_{\\rm geo}$ and $Q_{\\rm fh}$ are the geothermal heat flux, and the frictional heat flux, respectively. The latter is defined by $$ Q_{\\rm fh} = \\tau_b \\cdot u_b = c | u_b |^{m+1}. $$ As a matter of fact, the ice enthalpy (or equivalently temperature and water content) feedbacks the dynamical model in two ways. The Enthalpy directly impacts the sliding basal parametrization, while variations in temperature and water content cause ice softening or hardening. Basal melt When the temperature hits the pressure-melting point at the glacier bed (i.e. $E \\ge E_{\\rm pmp}$), the basal melt rate is calculated via the following equation: $$ \\begin{equation} m_b = \\frac{Q_{fr}+Q_{geo} - K_{t,c} \\frac{\\partial E}{ \\partial z} }{\\rho_i L}. \\end{equation} $$ The basal melt rate is further adjusted positively to account for the drainage of the water content generated along the entire column. Water thickness The basal water thickness in the till $W_{till}$ is computed directly from the basal melt rate as follows: $$ \\begin{equation} \\frac{\\partial W_{till} }{ \\partial z} = \\frac{m_b}{\\rho_w} - C, \\end{equation} $$ where $C$ is a simple drainage parameter. The till is assumed to be saturated when it reaches the value $W_{till}^{max} = 2$ m, therefore, the till water thickness is bounded to this value. The effective thickness of water within the till $N_{till}$ is computed from the saturation ratio $s= W_{till} / W_{till}^{max}$ by the formula (Bueler and Pelt, GMD, 2015) : $$ \\begin{equation} N_{till} = \\min \\left{ P_0, N_0 \\left( \\frac{\\delta P_0}{N_0} \\right)^s 10^{(e_0/C_c)(1-s)} \\right}, \\end{equation} $$ where $P_0$ is the ice overburden pressure and the remaining parameters are constant. Sliding parametrization Last, the sliding coefficient $c$ is defined with the Mohr-Coulomb (Cuffey and Paterson, 2010) sliding law with the effective pressure in the till: $$ \\begin{align} c = \\tau_c u_{th}^{-m} & = N_{till} \\tan(\\phi) u_{th}^{-m}, \\ \\end{align} $$ where $\\phi$ is the till friction angle. Ahrrenius factor We use the Glen-Paterson-Budd-Lliboutry-Duval law, where $$A(T,\\omega)= A_c(T)(1+C \\omega) $$ where $A_c(T)$ is given by the Paterson-Budd law: $$ A_c(T)= A \\exp{( \u2212Q / (R \\, T_{pa}) )} $$ where $A$ and $Q$ have different values below and above a threshold temperature. $$ A = 3.985 \\times 10^{-13} \\, s^{-1} Pa^{-3}, \\textrm{ if } T <263.15 K$$ $$ A = 1.916 \\times 10^3 \\, s^{-1} Pa^{-3}, \\textrm{else.}$$ and $$ Q = 60 kJ mol^{-1}, \\textrm{ if } T <263.15 K$$ $$ Q = 139 kJ mol^{-1}, \\textrm{else.}$$ These values are taken from (Paterson 1994). Pressure-adujsuted temperature Melting point temperature at pressure is adjusted for pressure as follows $$ T_{pmp} = T_{0} - \\beta \\rho g d, $$ where $d$ is the depth, $T_{0}=273.15$ is the melting temperate at standart pressure (unit [$K$]), $\\beta = 7.9 \\; 10^{-8}$ is Clausius-Clapeyron constant (unit [$K Pa^{-1}$]). Therefore, one define the \"pressure-adjusted\" temperaure $T_{pa}$ as being the temperature with a shift such that its metling point temperature reference is always zero: $$ T_{pa} = T + \\beta \\rho g z. $$ Numerical scheme To solve the Enthalpy equation numerically, one makes use of the same horizontal and vertical discretization as used for the ice flow. Treating the horizontal advection term explicitly using an upwind scheme, the Enthalpy equation with its boundary conditions can be solved column-wise as a one-dimensional advection-diffusion equation. This is achieved implicitly for both the vertical advection and the diffusion term, which are approximated by finite differences. For each column, one solves a small tridiagonal using the Tridiagonal Matrix Algorithm (TDMA) aka Thomas Algorithm. Updating the Enthalpy at time $t^{n+1}$ requires to perform several sub-steps (in function ''update_enthalpy(params,state)''): compute the mean surface temperature $T^n_s$ to enforce upper surface Dirichlet Boundary condition, compute the vertical discretization with respect to the ice geometry $h^n$, compute the temperature $T_{pmp}$ and enthalpy $E_{pmp}$ at pressure meltinf point, compute the ice temperature field $T^n$ from the Enthalpy $E^n$, compute the Arrhenius factor $A(T^n)$ from temperature $T^n$, compute the 3D strain heat $\\phi^n$ from ice flow field ${\\bf u}^{n+1}$ and rrhenius factor $A(T^n)$, compute the 2D basal frictional heat $Q_{\\rm fh}^n$, from basal velocity field ${\\bf u}$ and sliding coefficient $c^n$, compute the $UPWIND^n$ term for the explicit treatement of the horizontal advection, compute the surface Enthalpy $E^n_s$ from the surface temperature $T^n_s$, compute the new enthalpy $E^{n+1}$ field solving one-dimension column-wise advection-diffusion equation, as well as the basal melt rate, this is the main updating step , compute the water thickness in the till $W^{n+1}$, compute the sliding parametrization $c^{n+1}$. Numerical stability -- time stepping Here one updates the enthalpy as many times as the ice flow, we assume that the time step for the explicit advection is more restrictive than the implicit diffusion-advection problem. Dependencies the enthalpy module builds upon the module iceflow one needs to have the vertical_iceflow module activated to provide the vertical velocitiy make sure to have params.dim_arrhenius = 3 make sure to have params.new_friction_param = true make sure to ave enough retraining retrain_iceflow_emulator_freq: 1, possibly retrain_iceflow_emulator_nbit more than 1.","title":"enthalpy"},{"location":"modules/enthalpy/#igm-enthalpy-module","text":"","title":"IGM enthalpy module"},{"location":"modules/enthalpy/#description","text":"This IGM module models the ice enthalpy, which permits to jointly model the ice temperature, as well as the water content created when the temperature hits the pressure melting points, and therefore energy conservation, which is not the case when modelling the sole temperature variable. The model is described in (Aschwanden and al, JOG, 2012) . Here, we used a simplified version largely inspired from the one implemented in PISM . Other references that have helped are (Kleiner and al, TC, 2015) and (Wang and al, 2020) .","title":"Description:"},{"location":"modules/enthalpy/#model","text":"","title":"Model:"},{"location":"modules/enthalpy/#ice-flow","text":"Here we only quickly sketch the components of the ice dynamical modelling necessary for modeling the Enthalpy. Ice is assumed to be a Non Newtonian fluid, gouverned by Glen's flow law: $$ \\tau = A^{-1/n} | D({\\bf u}) |^{1/n-1} D({\\bf u}), $$ where $D({\\bf U})$ and $\\tau$ are the strain rate and deviatoric stress tensor, respectively. While a no-stress condition is applied on the top surface, we assume that the basal shear stress $\\tau_b$ and the sliding velocity $u_b$ are linked by Weertmann power law at the glacier bed interface: $$ \\tau_b = - c | u_b |^{m-1} u_b, $$ where $c=\\tau_c u_{th}^{-m}$ (unit: $Mpa \\; m^{-m} \\; y^m$), $\\tau_c$ being the yield stress and $u_{th}$ being a parameter homegenous to ice velocity. This formalism is taken from PISM. (Note that originally, IGM had $c^{-m}$ instead of $c$ above as \"slidingco\" with $u_{th}=1$. The newest runs under parameters \"new_sliding_param\", and $c$ has unit $MPa \\; m^{-m} \\; y^m$)","title":"Ice flow"},{"location":"modules/enthalpy/#enthalpy","text":"The Enthalpy $E$ is a 3D variable defined everywhere in the ice as a function of the temperature $T$ and the water content $\\omega$: $$ \\begin{align} E(T, \\omega,p) = \\left{ \\begin{array}{ll} c_i (T- T_{\\rm ref}), & {\\rm if } \\; T < T_{\\rm pmp} , \\ E_{\\rm pmp} + L \\omega, & {\\rm if } \\; T = T_{\\rm pmp} \\; {\\rm and } \\; 0 \\le \\omega, \\end{array} \\right. \\end{align} $$ where $c_i$ is the heat capacity, $T_{ref}$ is the reference temperature, $T_{\\rm pmp} = T_{\\rm pmp}(p) = T_0 - \\beta p$ is the temperature pressure-melting point of ice, $E_{\\rm pmp}(p)$ is the enthalpy pressure-melting point of ice defined as $$ E_{\\rm pmp}(p) = c_i (T_{\\rm pmp}(p) - T_{\\rm ref}), $$ where $L$ is the latent heat of fusion. According to the above defintion of enthalpy, we have two possible modes: i) the ice is cold, i.e. below the melting point, and the Enthalpy is simply proportional to the temperature minus a reference temperature ii) the ice is temperate and the Enthalpy continue to grow, the additional component $L \\omega$ corresponding to the creation of water content by energy transfer. Therefore, it is straightforward to deduce $E$ from $T$ and $\\omega$. The enthalpy model consists of the following advection-diffusion equation (the horizontal diffusion being neglected): $$ \\begin{align} & \\rho_i \\left( \\frac{\\partial E}{ \\partial t} + u_x \\frac{\\partial E}{ \\partial x} + u_y \\frac{\\partial E}{ \\partial y} + u_z \\frac{\\partial E}{ \\partial z} \\right) - \\frac{\\partial }{\\partial z} \\left( K_{c,t} \\frac{\\partial E}{ \\partial z} \\right) = \\phi - \\rho_w L D_w(\\omega), \\end{align} $$ where $\\rho_i$ is the ice density, $K_{c,t}$ equals $K_c = k_i/c_i$ if the ice is cold ($E<E_{pmp}$) or $K_t = \\epsilon k_i/c_i$ otherwise, $\\phi$ is the strain heating defined by (using Glen's flow law) $$ \\phi = D({\\bf U}) \\tau = A^{-1/n} | D({\\bf u}) |^{1+1/n}, $$ where $D({\\bf U})$ and $\\tau$ are the strain rate and deviatoric stress tensor, respectively. The last source term $- \\rho_w L D_w(\\omega)$ permits to remove the water in temperate ice $D_w(\\omega)$ being a drainage function ((Greve, 1997) and (Aschwanden et al., 2012)). At the top ice surface, the enthalpy equation is constrained by the surface temperature (or equivalently the Enthalpy) provided by the climate forcing (Dirichlet condition). At the glacier bed, boundary conditions for the enthalpy equation are multiple ( (Aschwanden and al, JOG, 2012) , (Kleiner and al, TC, 2015) and (Wang and al, 2020) .) $K_{c} \\frac{\\partial E}{ \\partial z} = Q_{\\rm geo} + Q_{\\rm fh}$ if $E_b<E_{\\rm pmp}$ and $H_w = 0$, (cold base, dry) $ E_b = E_{\\rm pmp} $ if $E_b 0$, (cold base, wet) $ E_b = E_{\\rm pmp} $ if $E_b \\ge E_{\\rm pmp}$ and $W_{till}> 0$, zero temperate basal layer, (temperate base, cold ice) $ K_{t} \\frac{\\partial E}{ \\partial z} = 0$ if $E_b \\ge E_{\\rm pmp}$ and $W_{till} > 0$, non-zero temperate basal layer, (temperate base, temp. ice) where $H_t$ is the height of the temperate basal layer, $Q_{\\rm geo}$ and $Q_{\\rm fh}$ are the geothermal heat flux, and the frictional heat flux, respectively. The latter is defined by $$ Q_{\\rm fh} = \\tau_b \\cdot u_b = c | u_b |^{m+1}. $$ As a matter of fact, the ice enthalpy (or equivalently temperature and water content) feedbacks the dynamical model in two ways. The Enthalpy directly impacts the sliding basal parametrization, while variations in temperature and water content cause ice softening or hardening.","title":"Enthalpy"},{"location":"modules/enthalpy/#basal-melt","text":"When the temperature hits the pressure-melting point at the glacier bed (i.e. $E \\ge E_{\\rm pmp}$), the basal melt rate is calculated via the following equation: $$ \\begin{equation} m_b = \\frac{Q_{fr}+Q_{geo} - K_{t,c} \\frac{\\partial E}{ \\partial z} }{\\rho_i L}. \\end{equation} $$ The basal melt rate is further adjusted positively to account for the drainage of the water content generated along the entire column.","title":"Basal melt"},{"location":"modules/enthalpy/#water-thickness","text":"The basal water thickness in the till $W_{till}$ is computed directly from the basal melt rate as follows: $$ \\begin{equation} \\frac{\\partial W_{till} }{ \\partial z} = \\frac{m_b}{\\rho_w} - C, \\end{equation} $$ where $C$ is a simple drainage parameter. The till is assumed to be saturated when it reaches the value $W_{till}^{max} = 2$ m, therefore, the till water thickness is bounded to this value. The effective thickness of water within the till $N_{till}$ is computed from the saturation ratio $s= W_{till} / W_{till}^{max}$ by the formula (Bueler and Pelt, GMD, 2015) : $$ \\begin{equation} N_{till} = \\min \\left{ P_0, N_0 \\left( \\frac{\\delta P_0}{N_0} \\right)^s 10^{(e_0/C_c)(1-s)} \\right}, \\end{equation} $$ where $P_0$ is the ice overburden pressure and the remaining parameters are constant.","title":"Water thickness"},{"location":"modules/enthalpy/#sliding-parametrization","text":"Last, the sliding coefficient $c$ is defined with the Mohr-Coulomb (Cuffey and Paterson, 2010) sliding law with the effective pressure in the till: $$ \\begin{align} c = \\tau_c u_{th}^{-m} & = N_{till} \\tan(\\phi) u_{th}^{-m}, \\ \\end{align} $$ where $\\phi$ is the till friction angle.","title":"Sliding parametrization"},{"location":"modules/enthalpy/#ahrrenius-factor","text":"We use the Glen-Paterson-Budd-Lliboutry-Duval law, where $$A(T,\\omega)= A_c(T)(1+C \\omega) $$ where $A_c(T)$ is given by the Paterson-Budd law: $$ A_c(T)= A \\exp{( \u2212Q / (R \\, T_{pa}) )} $$ where $A$ and $Q$ have different values below and above a threshold temperature. $$ A = 3.985 \\times 10^{-13} \\, s^{-1} Pa^{-3}, \\textrm{ if } T <263.15 K$$ $$ A = 1.916 \\times 10^3 \\, s^{-1} Pa^{-3}, \\textrm{else.}$$ and $$ Q = 60 kJ mol^{-1}, \\textrm{ if } T <263.15 K$$ $$ Q = 139 kJ mol^{-1}, \\textrm{else.}$$ These values are taken from (Paterson 1994).","title":"Ahrrenius factor"},{"location":"modules/enthalpy/#pressure-adujsuted-temperature","text":"Melting point temperature at pressure is adjusted for pressure as follows $$ T_{pmp} = T_{0} - \\beta \\rho g d, $$ where $d$ is the depth, $T_{0}=273.15$ is the melting temperate at standart pressure (unit [$K$]), $\\beta = 7.9 \\; 10^{-8}$ is Clausius-Clapeyron constant (unit [$K Pa^{-1}$]). Therefore, one define the \"pressure-adjusted\" temperaure $T_{pa}$ as being the temperature with a shift such that its metling point temperature reference is always zero: $$ T_{pa} = T + \\beta \\rho g z. $$","title":"Pressure-adujsuted temperature"},{"location":"modules/enthalpy/#numerical-scheme","text":"To solve the Enthalpy equation numerically, one makes use of the same horizontal and vertical discretization as used for the ice flow. Treating the horizontal advection term explicitly using an upwind scheme, the Enthalpy equation with its boundary conditions can be solved column-wise as a one-dimensional advection-diffusion equation. This is achieved implicitly for both the vertical advection and the diffusion term, which are approximated by finite differences. For each column, one solves a small tridiagonal using the Tridiagonal Matrix Algorithm (TDMA) aka Thomas Algorithm. Updating the Enthalpy at time $t^{n+1}$ requires to perform several sub-steps (in function ''update_enthalpy(params,state)''): compute the mean surface temperature $T^n_s$ to enforce upper surface Dirichlet Boundary condition, compute the vertical discretization with respect to the ice geometry $h^n$, compute the temperature $T_{pmp}$ and enthalpy $E_{pmp}$ at pressure meltinf point, compute the ice temperature field $T^n$ from the Enthalpy $E^n$, compute the Arrhenius factor $A(T^n)$ from temperature $T^n$, compute the 3D strain heat $\\phi^n$ from ice flow field ${\\bf u}^{n+1}$ and rrhenius factor $A(T^n)$, compute the 2D basal frictional heat $Q_{\\rm fh}^n$, from basal velocity field ${\\bf u}$ and sliding coefficient $c^n$, compute the $UPWIND^n$ term for the explicit treatement of the horizontal advection, compute the surface Enthalpy $E^n_s$ from the surface temperature $T^n_s$, compute the new enthalpy $E^{n+1}$ field solving one-dimension column-wise advection-diffusion equation, as well as the basal melt rate, this is the main updating step , compute the water thickness in the till $W^{n+1}$, compute the sliding parametrization $c^{n+1}$.","title":"Numerical scheme"},{"location":"modules/enthalpy/#numerical-stability-time-stepping","text":"Here one updates the enthalpy as many times as the ice flow, we assume that the time step for the explicit advection is more restrictive than the implicit diffusion-advection problem.","title":"Numerical stability -- time stepping"},{"location":"modules/enthalpy/#dependencies","text":"the enthalpy module builds upon the module iceflow one needs to have the vertical_iceflow module activated to provide the vertical velocitiy make sure to have params.dim_arrhenius = 3 make sure to have params.new_friction_param = true make sure to ave enough retraining retrain_iceflow_emulator_freq: 1, possibly retrain_iceflow_emulator_nbit more than 1.","title":"Dependencies"},{"location":"modules/flow_dt_thk/","text":"IGM module flow_dt_thk Description: This IGM module wraps up module iceflow, time and thk (check for each modules for the documentation).","title":"Flow dt thk"},{"location":"modules/flow_dt_thk/#igm-module-flow_dt_thk","text":"","title":"IGM module flow_dt_thk"},{"location":"modules/flow_dt_thk/#description","text":"This IGM module wraps up module iceflow, time and thk (check for each modules for the documentation).","title":"Description:"},{"location":"modules/gflex/","text":"IGM isostasy_gfex module Description: This IGM module permits to model the isostasy or upward motion of the lithosphere when loaded with thick ice, it uses the gflex python module writen by Andy Wickert. This function was implemented in IGM by J\u00fcrgen Mey. Parameters are the update frequency gflex_update_freq and the Elastic thickness [m] (Te) gflex_default_Te . This module only runs on CPU, which may be an issue for treating very large arrays. On the other hand, we do not expect a frequent update, therefore, this module should not be overall too consuming.","title":"gflex"},{"location":"modules/gflex/#igm-isostasy_gfex-module","text":"","title":"IGM isostasy_gfex module"},{"location":"modules/gflex/#description","text":"This IGM module permits to model the isostasy or upward motion of the lithosphere when loaded with thick ice, it uses the gflex python module writen by Andy Wickert. This function was implemented in IGM by J\u00fcrgen Mey. Parameters are the update frequency gflex_update_freq and the Elastic thickness [m] (Te) gflex_default_Te . This module only runs on CPU, which may be an issue for treating very large arrays. On the other hand, we do not expect a frequent update, therefore, this module should not be overall too consuming.","title":"Description:"},{"location":"modules/glerosion/","text":"IGM module glerosion Description: This IGM module implements change in basal topography (due to glacial erosion). The bedrock is updated (with a frequency provided by parameter glerosion_update_freq years ) assuming a power erosion law, i.e. the erosion rate is proportional (parameter glerosion_cst ) to a power (parameter glerosion_exp ) of the sliding velocity magnitude. By default, we use the parameters from Herman, F. et al., Erosion by an Alpine glacier. Science 350, 193-195, 2015.","title":"glerosion"},{"location":"modules/glerosion/#igm-module-glerosion","text":"","title":"IGM module glerosion"},{"location":"modules/glerosion/#description","text":"This IGM module implements change in basal topography (due to glacial erosion). The bedrock is updated (with a frequency provided by parameter glerosion_update_freq years ) assuming a power erosion law, i.e. the erosion rate is proportional (parameter glerosion_cst ) to a power (parameter glerosion_exp ) of the sliding velocity magnitude. By default, we use the parameters from Herman, F. et al., Erosion by an Alpine glacier. Science 350, 193-195, 2015.","title":"Description:"},{"location":"modules/iceflow/","text":"IGM module iceflow Description: This IGM module models ice flow dynamics in 3D using a Convolutional Neural Network based on Physics Informed Neural Network as described in this paper . In more details, we train a CNN to minimise the energy associated with high-order ice flow equations within the time iterations of a glacier evolution model. As a result, our iflo_emulator is a computationally-efficient alternative to traditional solvers, it is capable to handle a variety of ice flow regimes and memorize previous solutions. Pre-trained emulators are provided by defaults (parameter iflo_emulator ). However, a from scratch iflo_emulator can be requested with iflo_emulator=\"\" . The most important parameters are: physical parameters \"iflo_init_slidingco\": 10000.0 # Init slid. coeff. ($Mpa^{-3} y^{-1} m$) \"iflo_init_arrhenius\": 78.0 # Init Arrhenius cts ($Mpa^{-3} y^{-1}$) \"iflo_exp_glen\": 3 # Glen's exponent \"iflo_exp_weertman\": 3 # Weertman's sliding law exponent related to the vertical discretization: \"iflo_Nz\": 10 # number of vertical layers \"iflo_vert_spacing\": 4.0 # 1.0 for equal vertical spacing, 4.0 otherwise learning rate and frequency of retraining: \"iflo_retrain_emulator_lr\": 0.00002 \"iflo_retrain_emulator_freq\": 5 While this module was targeted for deep learning emulation, it important parameters for solving are : is possible to use the solver ( iflo_type='solved' ) instead of the default iflo_emulator ( iflo_type='emulated' ), or use the two together ( iflo_type='diagnostic' ) to assess the emaultor against the solver. Most important parameters for solving are : \"iflo_solve_step_size\": 0.00002 \"iflo_solve_nbitmax\": 5 One may choose between 2D arrhenius factor by changing parameters between iflo_dim_arrhenius=2 or iflo_dim_arrhenius=3 -- le later is necessary for the enthalpy model. When treating ery large arrays, retraining must be done sequentially patch-wise for memory reason. The size of the pathc is controlled by parameter iflo_multiple_window_size=750 . Reference @article{jouvet2023ice, title={Ice flow model emulator based on physics-informed deep learning}, author={Jouvet, Guillaume and Cordonnier, Guillaume}, year={2023}, publisher={EarthArXiv} }","title":"iceflow"},{"location":"modules/iceflow/#igm-module-iceflow","text":"","title":"IGM module iceflow"},{"location":"modules/iceflow/#description","text":"This IGM module models ice flow dynamics in 3D using a Convolutional Neural Network based on Physics Informed Neural Network as described in this paper . In more details, we train a CNN to minimise the energy associated with high-order ice flow equations within the time iterations of a glacier evolution model. As a result, our iflo_emulator is a computationally-efficient alternative to traditional solvers, it is capable to handle a variety of ice flow regimes and memorize previous solutions. Pre-trained emulators are provided by defaults (parameter iflo_emulator ). However, a from scratch iflo_emulator can be requested with iflo_emulator=\"\" . The most important parameters are: physical parameters \"iflo_init_slidingco\": 10000.0 # Init slid. coeff. ($Mpa^{-3} y^{-1} m$) \"iflo_init_arrhenius\": 78.0 # Init Arrhenius cts ($Mpa^{-3} y^{-1}$) \"iflo_exp_glen\": 3 # Glen's exponent \"iflo_exp_weertman\": 3 # Weertman's sliding law exponent related to the vertical discretization: \"iflo_Nz\": 10 # number of vertical layers \"iflo_vert_spacing\": 4.0 # 1.0 for equal vertical spacing, 4.0 otherwise learning rate and frequency of retraining: \"iflo_retrain_emulator_lr\": 0.00002 \"iflo_retrain_emulator_freq\": 5 While this module was targeted for deep learning emulation, it important parameters for solving are : is possible to use the solver ( iflo_type='solved' ) instead of the default iflo_emulator ( iflo_type='emulated' ), or use the two together ( iflo_type='diagnostic' ) to assess the emaultor against the solver. Most important parameters for solving are : \"iflo_solve_step_size\": 0.00002 \"iflo_solve_nbitmax\": 5 One may choose between 2D arrhenius factor by changing parameters between iflo_dim_arrhenius=2 or iflo_dim_arrhenius=3 -- le later is necessary for the enthalpy model. When treating ery large arrays, retraining must be done sequentially patch-wise for memory reason. The size of the pathc is controlled by parameter iflo_multiple_window_size=750 .","title":"Description:"},{"location":"modules/iceflow/#reference","text":"@article{jouvet2023ice, title={Ice flow model emulator based on physics-informed deep learning}, author={Jouvet, Guillaume and Cordonnier, Guillaume}, year={2023}, publisher={EarthArXiv} }","title":"Reference"},{"location":"modules/iceflow_v1/","text":"IGM module ice_flow_v1 Description: This IGM module models ice flow using a Convolutional Neural Network following the former online training from external data. You may find trained and ready-to-use ice flow emulators in the folder emulators/T_M_I_Y_V/R/ , where 'T_M_I_Y_V' defines the iflo_emulator, and R defines the spatial resolution. Make sure that the resolution of the picked iflo_emulator is available in the database. Results produced with IGM will strongly rely on the chosen iflo_emulator. Make sure that you use the iflo_emulator within the hull of its training dataset (e.g., do not model an ice sheet with an iflo_emulator trained with mountain glaciers) to ensure reliability (or fidelity w.r.t to the instructor model) -- the iflo_emulator is probably much better at interpolating than at extrapolating. Information on the training dataset is provided in a dedicated README coming along with the iflo_emulator. At the time of writing, I recommend using f15_cfsflow_GJ_22_a , which takes ice thickness, top surface slopes, the sliding coefficient c ('slidingco'), and Arrhenuis factor A ('arrhenius'), and return basal, vertical-average and surface x- and y- velocity components. I have trained f15_cfsflow_GJ_22_a using a large dataset of modeled glaciers (based on a Stokes-based CfsFlow ice flow solver) and varying sliding coefficient c, and Arrhenius factor A into a 2D space. It takes as inputs (thk, usurf, arrhenuis, slidingco) and provides as output: (ubar,vbar, uvelsurf, vvelsurf, uvelbase, vvelbase)","title":"Iceflow v1"},{"location":"modules/iceflow_v1/#igm-module-ice_flow_v1","text":"","title":"IGM module ice_flow_v1"},{"location":"modules/iceflow_v1/#description","text":"This IGM module models ice flow using a Convolutional Neural Network following the former online training from external data. You may find trained and ready-to-use ice flow emulators in the folder emulators/T_M_I_Y_V/R/ , where 'T_M_I_Y_V' defines the iflo_emulator, and R defines the spatial resolution. Make sure that the resolution of the picked iflo_emulator is available in the database. Results produced with IGM will strongly rely on the chosen iflo_emulator. Make sure that you use the iflo_emulator within the hull of its training dataset (e.g., do not model an ice sheet with an iflo_emulator trained with mountain glaciers) to ensure reliability (or fidelity w.r.t to the instructor model) -- the iflo_emulator is probably much better at interpolating than at extrapolating. Information on the training dataset is provided in a dedicated README coming along with the iflo_emulator. At the time of writing, I recommend using f15_cfsflow_GJ_22_a , which takes ice thickness, top surface slopes, the sliding coefficient c ('slidingco'), and Arrhenuis factor A ('arrhenius'), and return basal, vertical-average and surface x- and y- velocity components. I have trained f15_cfsflow_GJ_22_a using a large dataset of modeled glaciers (based on a Stokes-based CfsFlow ice flow solver) and varying sliding coefficient c, and Arrhenius factor A into a 2D space. It takes as inputs (thk, usurf, arrhenuis, slidingco) and provides as output: (ubar,vbar, uvelsurf, vvelsurf, uvelbase, vvelbase)","title":"Description:"},{"location":"modules/include_icemask/","text":"IGM module include_icemask Description: This IGM module loads a shapefile (ESRI shapefile) and creates an ice mask from it. The shapefile can be either the coordinates where there should be no glacier (default) or where there should be glaciers ( mask_invert = True). Input: Shapefile (.shp) exported from any GIS program (e.g. QGIS). Output: state.icemask This module can be used with any igm setup that calculates the new glacier surface via the state.smb variable. For example add to smb_simple.py : # if an icemask exists, then force negative smb if hasattr(state, \"icemask\") state.smb = tf.where((state.smb<0)|(state.icemask>0.5),state.smb,-10) Add this module in the list of \"modules_preproc\" after loading the topography input. The input can be one or more polygon features. Sometimes it is easier to select the valley where the glacier should be ( mask_invert = True) or draw polygons where the glacier should not be (e.g. side valleys with no further interest). IMPORTANT: Be aware of the coordinate system used in the nc file and the shapefile. Author: Andreas Henz, andreas.henz@geo.uzh.ch (06.09.2023)","title":"include_icemask"},{"location":"modules/include_icemask/#igm-module-include_icemask","text":"","title":"IGM module include_icemask"},{"location":"modules/include_icemask/#description","text":"This IGM module loads a shapefile (ESRI shapefile) and creates an ice mask from it. The shapefile can be either the coordinates where there should be no glacier (default) or where there should be glaciers ( mask_invert = True). Input: Shapefile (.shp) exported from any GIS program (e.g. QGIS). Output: state.icemask This module can be used with any igm setup that calculates the new glacier surface via the state.smb variable. For example add to smb_simple.py : # if an icemask exists, then force negative smb if hasattr(state, \"icemask\") state.smb = tf.where((state.smb<0)|(state.icemask>0.5),state.smb,-10) Add this module in the list of \"modules_preproc\" after loading the topography input. The input can be one or more polygon features. Sometimes it is easier to select the valley where the glacier should be ( mask_invert = True) or draw polygons where the glacier should not be (e.g. side valleys with no further interest). IMPORTANT: Be aware of the coordinate system used in the nc file and the shapefile. Author: Andreas Henz, andreas.henz@geo.uzh.ch (06.09.2023)","title":"Description:"},{"location":"modules/infersmb/","text":"IGM module infersmb Description: This IGM module computes the smb from the oggm_clim and oggm_smb files over 20 yeras from 2000 to 2020 to match the period of the hugonnet dataset","title":"Infersmb"},{"location":"modules/infersmb/#igm-module-infersmb","text":"","title":"IGM module infersmb"},{"location":"modules/infersmb/#description","text":"This IGM module computes the smb from the oggm_clim and oggm_smb files over 20 yeras from 2000 to 2020 to match the period of the hugonnet dataset","title":"Description:"},{"location":"modules/load_ncdf/","text":"IGM module load_ncdf Description: This IGM module loads spatial 2D raster data from a NetCDF file (parameter lncd_input_file , default: input.nc) and transform all existing 2D fields into tensorflow variables. It is expected here to import at least basal topography (variable topg ). It also complete the data, e.g. the basal topography from ice thickness and surface topography. However, any other field present in NetCDF file will be passed as tensorflow variables, and will therefore be available in the code through state.myvar (e.g. variable icemask can be provided, and served to define an accumulation area -- this is usefull for modelling an individual glaciers, and prevent overflowing in neighbouring catchements). The module also contains the two functions for resampling (parameter lncd_coarsen should be increased to 2,3,4 ..., default 1 value means no coarsening) and cropping the data (parameter lncd_crop should be set to True, and the bounds must be definined as wished). It is possible to restart an IGM run by reading data in an nNetCDF file obtained as a previous IGM run. To that aim, one needs to provide the NETcdf output file as input to IGM. IGM will look for the data that corresponds to the starting time params.time_start , and then intialize it with this time. This module depends on netCDF4 .","title":"load_ncdf"},{"location":"modules/load_ncdf/#igm-module-load_ncdf","text":"","title":"IGM module load_ncdf"},{"location":"modules/load_ncdf/#description","text":"This IGM module loads spatial 2D raster data from a NetCDF file (parameter lncd_input_file , default: input.nc) and transform all existing 2D fields into tensorflow variables. It is expected here to import at least basal topography (variable topg ). It also complete the data, e.g. the basal topography from ice thickness and surface topography. However, any other field present in NetCDF file will be passed as tensorflow variables, and will therefore be available in the code through state.myvar (e.g. variable icemask can be provided, and served to define an accumulation area -- this is usefull for modelling an individual glaciers, and prevent overflowing in neighbouring catchements). The module also contains the two functions for resampling (parameter lncd_coarsen should be increased to 2,3,4 ..., default 1 value means no coarsening) and cropping the data (parameter lncd_crop should be set to True, and the bounds must be definined as wished). It is possible to restart an IGM run by reading data in an nNetCDF file obtained as a previous IGM run. To that aim, one needs to provide the NETcdf output file as input to IGM. IGM will look for the data that corresponds to the starting time params.time_start , and then intialize it with this time. This module depends on netCDF4 .","title":"Description:"},{"location":"modules/load_tif/","text":"IGM module load_tif Description: This IGM module loads spatial 2D raster data from any tif file present in the working directory folder, and transform each of them into tensorflow variables, the name of the file becoming the name of the variable, e.g. the file topg.tif will yield variable topg, ect... It is expected here to import at least basal topography (variable topg ). It also complete the data, e.g. the basal topography from ice thickness and surface topography. Note that all these variables will therefore be available in the code with state.myvar from myvar.tif (e.g. variable icemask can be provided, and served to define an accumulation area -- this is usefull for modelling an individual glaciers, and prevent overflowing in neighbouring catchements). The module also contains two functions for resampling (parameter ltif_coarsen should be increased to 2,3,4 ..., default 1 value means no coarsening) and cropping the data (parameter ltif_crop should be set to True, and the bounds must be definined as wished). This module depends on rasterio .","title":"load_tif"},{"location":"modules/load_tif/#igm-module-load_tif","text":"","title":"IGM module load_tif"},{"location":"modules/load_tif/#description","text":"This IGM module loads spatial 2D raster data from any tif file present in the working directory folder, and transform each of them into tensorflow variables, the name of the file becoming the name of the variable, e.g. the file topg.tif will yield variable topg, ect... It is expected here to import at least basal topography (variable topg ). It also complete the data, e.g. the basal topography from ice thickness and surface topography. Note that all these variables will therefore be available in the code with state.myvar from myvar.tif (e.g. variable icemask can be provided, and served to define an accumulation area -- this is usefull for modelling an individual glaciers, and prevent overflowing in neighbouring catchements). The module also contains two functions for resampling (parameter ltif_coarsen should be increased to 2,3,4 ..., default 1 value means no coarsening) and cropping the data (parameter ltif_crop should be set to True, and the bounds must be definined as wished). This module depends on rasterio .","title":"Description:"},{"location":"modules/oggm_shop/","text":"IGM module oggm_shop Description: This IGM module uses OGGM utilities and GlaThiDa dataset to prepare data for the IGM model for a specific glacier given the RGI ID (parameter oggm_RGI_ID ), check at GLIMS VIeWER to find the RGI ID of your glacier (only for RGI 6.0 - if using RGI 7.0, please download the RGI shapefiles and use the enquire function in your GIS software to find the right ID - by default, IGM looks at RGI 7.0C here . but modifying line 304 of the module to '70G' instead of '70C' will give you that version instead. This may be made a parameter in the future once the RGI 7.0 release and associated OGGM data are all finalised). By default, data are already processed (parameter oggm_preprocess is True), with spatial resolution of 100 m and an oggm_border size of 30 m. For custom spatial resolution and size of 'oggm_border' to keep a safe distance to the glacier margin, one need to set oggm_preprocess parameter to False, and set oggm_dx and oggm_border parameter as desired. The module directly provides IGM with all 2D gridded variables (as tensorflow object), and are accessible in the code with e.g. state.thk . By default a copy of all the data are stored in a NetCDF file input_saved.nc so that this file can be readed directly in a second run with module load_ncdf instead of re-downloading the data with oggm_shop again. The module provides all data variables necessary to run IGM for a forward glacier evolution run (assuming we provide basal topography topg and ice thickness thk ), or a preliminary data assimilation/ inverse modelling with the optimize module further data (typically icemaskobs , thkinit , uvelsurf , vvelsurf , thkobs , usurfobs ). Data are currently based on COPERNICUS DEM 90 for the top surface DEM, the surface ice velocity from (Millan, 2022), the ice thickness from (Millan, 2022) or (farinotti2019) (the user can choose with parameter oggm_thk_source between millan_ice_thickness or consensus_ice_thickness dataset). When activating oggm_include_glathida to True, ice thickness profiles are downloaded from the GlaThiDa depo and are rasterized with name thkobs (pixels without data are set to NaN values.) if using RGI 6.0. With RGI 7.0, the GlaThiDa data are downloaded for the specific glacier (defined by the RGI ID) from the OGGM server and are found as a text file in the download folder created by this module (glathida_data.csv), from where they are subsequently read in, rasterised, and NaNs added where there are no observations. The OGGM script was written by Fabien Maussion. The GlaThiDa script was written by Ethan Welty & Guillaume Jouvet. RGI 7.0 modifications were written by Samuel Cook. The module depends (of course) on the oggm library. Unfortunately the module works on linux and Max, but not on windows (unless using WSL).","title":"oggm_shop"},{"location":"modules/oggm_shop/#igm-module-oggm_shop","text":"","title":"IGM module oggm_shop"},{"location":"modules/oggm_shop/#description","text":"This IGM module uses OGGM utilities and GlaThiDa dataset to prepare data for the IGM model for a specific glacier given the RGI ID (parameter oggm_RGI_ID ), check at GLIMS VIeWER to find the RGI ID of your glacier (only for RGI 6.0 - if using RGI 7.0, please download the RGI shapefiles and use the enquire function in your GIS software to find the right ID - by default, IGM looks at RGI 7.0C here . but modifying line 304 of the module to '70G' instead of '70C' will give you that version instead. This may be made a parameter in the future once the RGI 7.0 release and associated OGGM data are all finalised). By default, data are already processed (parameter oggm_preprocess is True), with spatial resolution of 100 m and an oggm_border size of 30 m. For custom spatial resolution and size of 'oggm_border' to keep a safe distance to the glacier margin, one need to set oggm_preprocess parameter to False, and set oggm_dx and oggm_border parameter as desired. The module directly provides IGM with all 2D gridded variables (as tensorflow object), and are accessible in the code with e.g. state.thk . By default a copy of all the data are stored in a NetCDF file input_saved.nc so that this file can be readed directly in a second run with module load_ncdf instead of re-downloading the data with oggm_shop again. The module provides all data variables necessary to run IGM for a forward glacier evolution run (assuming we provide basal topography topg and ice thickness thk ), or a preliminary data assimilation/ inverse modelling with the optimize module further data (typically icemaskobs , thkinit , uvelsurf , vvelsurf , thkobs , usurfobs ). Data are currently based on COPERNICUS DEM 90 for the top surface DEM, the surface ice velocity from (Millan, 2022), the ice thickness from (Millan, 2022) or (farinotti2019) (the user can choose with parameter oggm_thk_source between millan_ice_thickness or consensus_ice_thickness dataset). When activating oggm_include_glathida to True, ice thickness profiles are downloaded from the GlaThiDa depo and are rasterized with name thkobs (pixels without data are set to NaN values.) if using RGI 6.0. With RGI 7.0, the GlaThiDa data are downloaded for the specific glacier (defined by the RGI ID) from the OGGM server and are found as a text file in the download folder created by this module (glathida_data.csv), from where they are subsequently read in, rasterised, and NaNs added where there are no observations. The OGGM script was written by Fabien Maussion. The GlaThiDa script was written by Ethan Welty & Guillaume Jouvet. RGI 7.0 modifications were written by Samuel Cook. The module depends (of course) on the oggm library. Unfortunately the module works on linux and Max, but not on windows (unless using WSL).","title":"Description:"},{"location":"modules/optimize/","text":"window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\\\(', '\\\\)']], displayMath: [['$$', '$$'], ['\\\\[', '\\\\]']] }, svg: { fontCache: 'global' } }; IGM module optimize Description: A data assimilation module of IGM permits to seek optimal ice thickness, top ice surface, and ice flow parametrization, that best explains observational data such as surface ice speeds, ice thickness profiles, top ice surface while being consistent with the ice flow iflo_emulator used in forwrd modelling. This page explains how to use the data assimilation module as a preliminary step in IGM of a forward/prognostic model run with module optimize . Note that the optimization currently requires some experience, and some parameter tunning may be needed before getting a meanigfully results. Use it with care, and with a certain dose of parameter exploration. Do not hesitate to get in contact with us for chcecking the consistency of results. Getting the data The first thing you need to do is to get as much data as possible. Data list includes: Observed surface ice velocities ${\\bf u}^{s,obs}$, e.g. from Millan and al. (2022). Surface top elevation $s^{obs}$, e.g. SRTM, ESA GLO-30, ... Ice thickness profiles $h_p^{obs}$, e.g. GlaThiDa Glacier outlines, and resulting mask, e.g. from the Randolph Glacier Inventory. Of course, you may not have all these data, which is fine. You work with a reduced amount of data, however, you will have make assumptions to reduce the number of variables to optimize (controls) to keep the optimization problem well-posed (i.e., with a unique solution). Thes data can be obtained using the IGM module oggm_shop , or loading these 2D gridded variables using module load_ncdf or load_tif using convention variable names but ending with obs . E.g. usurfobs (observed top surface elevation), thkobs (observed thickness profiles, use nan or novalue where no data is available), icemaskobs (this mask from RGI outline serve to enforce zero ice thickness outside the mask), uvelsurfobs and vvelsurfobs (x- and y- components of the horizontal surface ice velocity, use nan or novalue where no data is available), thkinit (this may be a formerly-inferred ice thickness field to initalize the inverse model, otherwise it would start from thk=0). Use the IGM oggm_shop to download all the data you need using OGGM and the GlaThiDa database. General optimization setting The optimization problem consists of finding spatially varying fields ($h$, $c$, $s$) that minimize the cost function $$ \\mathcal{J}(h,c,s)=\\mathcal{C}^u+\\mathcal{C}^h+\\mathcal{C}^s+\\mathcal{C}^{d}+\\mathcal{R}^h+\\mathcal{R}^{c}+\\mathcal{P}^h, $$ where $\\mathcal{C}^u$ is the misfit between modeled and observed surface ice velocities ($\\mathcal{F}$ is the output of the ice flow iflo_emulator/neural iflo_network): $$\\mathcal{C}^u=\\int_{\\Omega}\\frac{1}{2\\sigma_u^2}\\left|{\\bf u}^{s,obs}-\\mathcal{F}(h,\\frac{\\partial s}{\\partial x},\\frac{\\partial s}{\\partial y},c)\\right|^2,$$ where $\\mathcal{C}^h$ is the misfit between modeled and observed ice thickness profiles: $$\\mathcal{C}^h=\\sum_{p=1,...,P} \\sum_{i=1,...,M_p}\\frac{1}{2 \\sigma_h^2}|h_p^{obs}(x^p_i, y^p_i)-h (x^p_i, y^p_i)|^2,$$ where $\\mathcal{C}^s$ is the misfit between the modeled and observed top ice surface: $$\\mathcal{C}^s=\\int_{\\Omega}\\frac{1}{2 \\sigma_s^2}\\left|s-s^{obs}\\right|^2,$$ where $\\mathcal{C}^{d}$ is a misfit term between the flux divergence and its polynomial regression $d$ with respect to the ice surface elevation $s(x,y)$ to enforce smoothness with dependence to $s$: $$\\mathcal{C}^{d}=\\int_{\\Omega}\\frac{1}{2 \\sigma_d^2}\\left|\\nabla \\cdot (h {\\bar{\\bf u}})-d \\right|^2,$$ where $\\mathcal{R}^h$ is a regularization term to enforce anisotropic smoothness and convexity of $h$: $$\\mathcal{R}^h=\\alpha_h\\int_{h>0}\\left(|\\nabla h \\cdot \\tilde{{\\bf u}}^{s,obs} |^2+\\beta|\\nabla h \\cdot (\\tilde{{\\bf u}}^{s,obs})^{\\perp} |^2-\\gamma h\\right),$$ where $\\mathcal{R}^{c}$ is a regularization term to enforce smooth c: $$\\mathcal{R}^{c}=\\alpha_{\\tilde{A}}\\int_{\\Omega}|\\nabla c|^2,$$ where $\\mathcal{P}^h$ is a penalty term to enforce nonnegative ice thickness, and zero thickness outside a given mask: $$\\mathcal{P}^h=10^{10} \\times \\left(\\int_{h<0} h^2+\\int_{\\mathcal{M}^{\\rm ice-free}} h^2 \\right).$$ Check at the reference paper given below for more explanation on the regularization terms. Define controls and cost components The above optimization problem is given in the most general case, however, you may select only some components according to your data as follows: the list of control variables you wish to optimize, e.g., \"opti_control\": ['thk','slidingco','usurf'] # this is the most general case \"opti_control\": ['thk','usurf'] # this will only optimize ice thk and top surf \"opti_control\": ['thk'] # this will only optimize ice thickness the list of cost components you wish to minimize, e.g. \"opti_cost\": ['velsurf','thk','usurf','divfluxfcz','icemask'] # most general case \"opti_cost\": ['velsurf','icemask'] # Here only fit surface velocity and ice mask. I recomend to start with a simple optimization, starting with one single control (typically thk ), and a few target/cost component (typically velsurf and icemask ), and then to increase the complexity of the optimization (adding controls and cost components) once the the most simple give meaningfull results. Make sure to keep a balance between controls and constraints to ensure the problem to keep the problem well-posed, and prevents against multiple solutions. Exploring parameters There are parameters that may need to tune for each application. First, you may change your expected confidence levels (i.e. tolerance to fit the data) $\\sigma^u, \\sigma^h, \\sigma^s, \\sigma^d$ to fit surface ice velocity, ice thickness, surface top elevation, or divergence of the flux as follows: \"opti_velsurfobs_std\": 5 # unit m/y \"opti_thkobs_std\" : 5 # unit m \"opti_usurfobs_std\" : 5 # unit m \"opti_divfluxobs_std\": 1 # unit m/y Second, you may change regularization parameters such as i) $\\alpha^h, \\alpha^A$, which control the regularization weights for the ice thickness and strflowctrl (increasing $\\alpha^h, \\alpha^A$ will make thse fields spatially smoother), or ii) parameters beta and gamma involved for regularizing the ice thickness h. Taking beta=1 occurs to enforce isotropic smoothing, reducing beta will make the smoothing more and more anisotropic to enforce further smoothing along ice flow directions than accross directions (as expected for the topography of a glacier bedrock, which was eroded over long times). Setting parameter gamma to a small value may be usefull to add a bit of convexity in the system. This may help when initializing the inverse modelled with zero thickness, or to treat margin regions with no data available. These parameters may be changed as follows: \"opti_regu_param_thk\": 10.0 # weight for the regul. of thk \"opti_regu_param_slidingco\": 1.0 # weight for the regul. of slidingco \"opti_smooth_anisotropy_factor\": 0.2 \"opti_convexity_weight\": 0.002 Lastly, there are a couple of other parameters we may be interest to change e.g. \"opti_nbitmax\": 1000 # Number of it. for the optimization \"opti_step_size\": 0.001 # step size in the optimization iterative algorithm \"opti_init_zero_thk\": True # Force init zero ice thk (otherwise take thkinit) Monitoring the optimization You may monitor the data assimilation during the inverse modelling in several ways: Check that the components of the costs decrease over time, the value of cost are printed during the optimization, and a graph is produced at the end. Set up parameter plot_result to True and plt2d_live to True to monitor in live time the evolution of the field your are optimizing such as the ice thickness, the surface ice speeds, ect ... You may also check (hopefully decreasing) STD given in the figure. You may do the same monitoring after the run looking at optimize.nc reuesting this file to be written. If you asked divfluxfcz to be in the parameter list opti_cost , you should check what look like the divergence of the flux (divflux). References @article{jouvet2023inversion, author = {Jouvet, Guillaume}, journal = {Journal of Glaciology}, number = {273}, pages = {13--26}, publisher = {Cambridge University Press}, title = {{Inversion of a Stokes glacier flow model emulated by deep learning}}, volume = {69}, year = {2023}, doi = {10.1017/jog.2022.41}, } @article{jouvet2023ice, title={Ice flow model emulator based on physics-informed deep learning}, author={Jouvet, Guillaume and Cordonnier, Guillaume}, year={2023}, publisher={EarthArXiv} }","title":"optimize"},{"location":"modules/optimize/#igm-module-optimize","text":"","title":"IGM module optimize"},{"location":"modules/optimize/#description","text":"A data assimilation module of IGM permits to seek optimal ice thickness, top ice surface, and ice flow parametrization, that best explains observational data such as surface ice speeds, ice thickness profiles, top ice surface while being consistent with the ice flow iflo_emulator used in forwrd modelling. This page explains how to use the data assimilation module as a preliminary step in IGM of a forward/prognostic model run with module optimize . Note that the optimization currently requires some experience, and some parameter tunning may be needed before getting a meanigfully results. Use it with care, and with a certain dose of parameter exploration. Do not hesitate to get in contact with us for chcecking the consistency of results.","title":"Description:"},{"location":"modules/optimize/#getting-the-data","text":"The first thing you need to do is to get as much data as possible. Data list includes: Observed surface ice velocities ${\\bf u}^{s,obs}$, e.g. from Millan and al. (2022). Surface top elevation $s^{obs}$, e.g. SRTM, ESA GLO-30, ... Ice thickness profiles $h_p^{obs}$, e.g. GlaThiDa Glacier outlines, and resulting mask, e.g. from the Randolph Glacier Inventory. Of course, you may not have all these data, which is fine. You work with a reduced amount of data, however, you will have make assumptions to reduce the number of variables to optimize (controls) to keep the optimization problem well-posed (i.e., with a unique solution). Thes data can be obtained using the IGM module oggm_shop , or loading these 2D gridded variables using module load_ncdf or load_tif using convention variable names but ending with obs . E.g. usurfobs (observed top surface elevation), thkobs (observed thickness profiles, use nan or novalue where no data is available), icemaskobs (this mask from RGI outline serve to enforce zero ice thickness outside the mask), uvelsurfobs and vvelsurfobs (x- and y- components of the horizontal surface ice velocity, use nan or novalue where no data is available), thkinit (this may be a formerly-inferred ice thickness field to initalize the inverse model, otherwise it would start from thk=0). Use the IGM oggm_shop to download all the data you need using OGGM and the GlaThiDa database.","title":"Getting the data"},{"location":"modules/optimize/#general-optimization-setting","text":"The optimization problem consists of finding spatially varying fields ($h$, $c$, $s$) that minimize the cost function $$ \\mathcal{J}(h,c,s)=\\mathcal{C}^u+\\mathcal{C}^h+\\mathcal{C}^s+\\mathcal{C}^{d}+\\mathcal{R}^h+\\mathcal{R}^{c}+\\mathcal{P}^h, $$ where $\\mathcal{C}^u$ is the misfit between modeled and observed surface ice velocities ($\\mathcal{F}$ is the output of the ice flow iflo_emulator/neural iflo_network): $$\\mathcal{C}^u=\\int_{\\Omega}\\frac{1}{2\\sigma_u^2}\\left|{\\bf u}^{s,obs}-\\mathcal{F}(h,\\frac{\\partial s}{\\partial x},\\frac{\\partial s}{\\partial y},c)\\right|^2,$$ where $\\mathcal{C}^h$ is the misfit between modeled and observed ice thickness profiles: $$\\mathcal{C}^h=\\sum_{p=1,...,P} \\sum_{i=1,...,M_p}\\frac{1}{2 \\sigma_h^2}|h_p^{obs}(x^p_i, y^p_i)-h (x^p_i, y^p_i)|^2,$$ where $\\mathcal{C}^s$ is the misfit between the modeled and observed top ice surface: $$\\mathcal{C}^s=\\int_{\\Omega}\\frac{1}{2 \\sigma_s^2}\\left|s-s^{obs}\\right|^2,$$ where $\\mathcal{C}^{d}$ is a misfit term between the flux divergence and its polynomial regression $d$ with respect to the ice surface elevation $s(x,y)$ to enforce smoothness with dependence to $s$: $$\\mathcal{C}^{d}=\\int_{\\Omega}\\frac{1}{2 \\sigma_d^2}\\left|\\nabla \\cdot (h {\\bar{\\bf u}})-d \\right|^2,$$ where $\\mathcal{R}^h$ is a regularization term to enforce anisotropic smoothness and convexity of $h$: $$\\mathcal{R}^h=\\alpha_h\\int_{h>0}\\left(|\\nabla h \\cdot \\tilde{{\\bf u}}^{s,obs} |^2+\\beta|\\nabla h \\cdot (\\tilde{{\\bf u}}^{s,obs})^{\\perp} |^2-\\gamma h\\right),$$ where $\\mathcal{R}^{c}$ is a regularization term to enforce smooth c: $$\\mathcal{R}^{c}=\\alpha_{\\tilde{A}}\\int_{\\Omega}|\\nabla c|^2,$$ where $\\mathcal{P}^h$ is a penalty term to enforce nonnegative ice thickness, and zero thickness outside a given mask: $$\\mathcal{P}^h=10^{10} \\times \\left(\\int_{h<0} h^2+\\int_{\\mathcal{M}^{\\rm ice-free}} h^2 \\right).$$ Check at the reference paper given below for more explanation on the regularization terms.","title":"General optimization setting"},{"location":"modules/optimize/#define-controls-and-cost-components","text":"The above optimization problem is given in the most general case, however, you may select only some components according to your data as follows: the list of control variables you wish to optimize, e.g., \"opti_control\": ['thk','slidingco','usurf'] # this is the most general case \"opti_control\": ['thk','usurf'] # this will only optimize ice thk and top surf \"opti_control\": ['thk'] # this will only optimize ice thickness the list of cost components you wish to minimize, e.g. \"opti_cost\": ['velsurf','thk','usurf','divfluxfcz','icemask'] # most general case \"opti_cost\": ['velsurf','icemask'] # Here only fit surface velocity and ice mask. I recomend to start with a simple optimization, starting with one single control (typically thk ), and a few target/cost component (typically velsurf and icemask ), and then to increase the complexity of the optimization (adding controls and cost components) once the the most simple give meaningfull results. Make sure to keep a balance between controls and constraints to ensure the problem to keep the problem well-posed, and prevents against multiple solutions.","title":"Define controls and cost components"},{"location":"modules/optimize/#exploring-parameters","text":"There are parameters that may need to tune for each application. First, you may change your expected confidence levels (i.e. tolerance to fit the data) $\\sigma^u, \\sigma^h, \\sigma^s, \\sigma^d$ to fit surface ice velocity, ice thickness, surface top elevation, or divergence of the flux as follows: \"opti_velsurfobs_std\": 5 # unit m/y \"opti_thkobs_std\" : 5 # unit m \"opti_usurfobs_std\" : 5 # unit m \"opti_divfluxobs_std\": 1 # unit m/y Second, you may change regularization parameters such as i) $\\alpha^h, \\alpha^A$, which control the regularization weights for the ice thickness and strflowctrl (increasing $\\alpha^h, \\alpha^A$ will make thse fields spatially smoother), or ii) parameters beta and gamma involved for regularizing the ice thickness h. Taking beta=1 occurs to enforce isotropic smoothing, reducing beta will make the smoothing more and more anisotropic to enforce further smoothing along ice flow directions than accross directions (as expected for the topography of a glacier bedrock, which was eroded over long times). Setting parameter gamma to a small value may be usefull to add a bit of convexity in the system. This may help when initializing the inverse modelled with zero thickness, or to treat margin regions with no data available. These parameters may be changed as follows: \"opti_regu_param_thk\": 10.0 # weight for the regul. of thk \"opti_regu_param_slidingco\": 1.0 # weight for the regul. of slidingco \"opti_smooth_anisotropy_factor\": 0.2 \"opti_convexity_weight\": 0.002 Lastly, there are a couple of other parameters we may be interest to change e.g. \"opti_nbitmax\": 1000 # Number of it. for the optimization \"opti_step_size\": 0.001 # step size in the optimization iterative algorithm \"opti_init_zero_thk\": True # Force init zero ice thk (otherwise take thkinit)","title":"Exploring parameters"},{"location":"modules/optimize/#monitoring-the-optimization","text":"You may monitor the data assimilation during the inverse modelling in several ways: Check that the components of the costs decrease over time, the value of cost are printed during the optimization, and a graph is produced at the end. Set up parameter plot_result to True and plt2d_live to True to monitor in live time the evolution of the field your are optimizing such as the ice thickness, the surface ice speeds, ect ... You may also check (hopefully decreasing) STD given in the figure. You may do the same monitoring after the run looking at optimize.nc reuesting this file to be written. If you asked divfluxfcz to be in the parameter list opti_cost , you should check what look like the divergence of the flux (divflux).","title":"Monitoring the optimization"},{"location":"modules/optimize/#references","text":"@article{jouvet2023inversion, author = {Jouvet, Guillaume}, journal = {Journal of Glaciology}, number = {273}, pages = {13--26}, publisher = {Cambridge University Press}, title = {{Inversion of a Stokes glacier flow model emulated by deep learning}}, volume = {69}, year = {2023}, doi = {10.1017/jog.2022.41}, } @article{jouvet2023ice, title={Ice flow model emulator based on physics-informed deep learning}, author={Jouvet, Guillaume and Cordonnier, Guillaume}, year={2023}, publisher={EarthArXiv} }","title":"References"},{"location":"modules/optimize_v1/","text":"IGM module optimize_v1 Description: A data assimilation module of IGM permits to seek optimal ice thickness, top ice surface, and ice flow parametrization (red variables in the following figure), that best explains observational data such as surface ice speeds, ice thickness profiles, top ice surface (blue variables in the following figure) while being consistent with the ice flow iflo_emulator used in forwrd modelling. This page explains how to use the data assimilation module as a preliminary step in IGM of a forward/prognostic model run. I recommend to read the paper reference given below before to proceed further. Getting the data The first thing you need to do is to get as much data as possible, this includes: Observed surface ice velocities ${\\bf u}^{s,obs}$, e.g. from Millan and al. (2022). Surface top elevation $s^{obs}$, e.g. SRTM, ESA GLO-30, ... Ice thickness profiles $h_p^{obs}$, e.g. GlaThiDa Glacier outlines, and resulting mask, e.g. from the Randolph Glacier Inventory. Of course, you may not have all these data, which is fine. You work with a reduced amount of data, however, you will have make assumptions to reduce the number of variables to optimize (controls) to keep the optimization problem well-posed (i.e., with a unique solution). All the data need to be assemblied in 2D raster grid in an netcdf file (called by default observation.nc) using convention variable names but ending with 'obs'. E.g. observation.nc contains fields 'usurfobs' (observed top surface elevation), 'thkobs' (observed thickness profiles, use nan or novalue where no data is available), 'icemaskobs' (this mask from RGI outline serve to enforce zero ice thickness outside the mask), 'uvelsurfobs' and 'vvelsurfobs' (x- and y- components of the horizontal surface ice velocity, use nan or novalue where no data is available), 'thkinit' (this may be a formerly-inferred ice thickness field to initalize the inverse model, otherwise it would start from thk=0). Use the IGM 'preprare_data' to download all the data you need using OGGM and the GlaThiDa database Asumption on the ice flow control Optimizing for both Arrhenius factor (A) and sliding coefficient (c) would lead to multiple solutions as several combinations of the two may explain the observed ice flow similarly. To deal with this issue, we introduce a single control of the ice flow strenght (named as 'strflowctrl' in IGM) $\\tilde{A}$ = A + lambda c, where A is the Arrhenius factor that controls the ice shearing from cold-ice case (low A) to temperate ice case (A=78), c is a sliding coefficient that controls the strength of basal motion from no sliding (c=0) to high sliding (high c) and lambda=1 is a given parameter. General optimization setting The optimization problem consists of finding spatially varying fields ($h$, $\\tilde{A}$, $s$) that minimize the cost function $$ \\mathcal{J}(h,\\tilde{A},s) = \\mathcal{C}^u + \\mathcal{C}^h + \\mathcal{C}^s + \\mathcal{C}^{d} + \\mathcal{R}^h + \\mathcal{R}^{\\tilde{A}} + \\mathcal{P}^h, $$ where $\\mathcal{C}^u$ is the misfit between modeled and observed surface ice velocities ($\\mathcal{F}$ is the output of the ice flow iflo_emulator/neural iflo_network): $$ \\mathcal{C}^u = \\int_{\\Omega} \\frac{1}{2 \\sigma_u^2} \\left| {\\bf u}^{s,obs} - \\mathcal{F}( h, \\frac{\\partial s}{\\partial x}, \\frac{\\partial s}{\\partial y}, \\tilde{A}) \\right|^2, $$ where $\\mathcal{C}^h$ is the misfit between modeled and observed ice thickness profiles: $$ \\mathcal{C}^h = \\sum_{p=1,...,P} \\sum_{i=1,...,M_p} \\frac{1}{2 \\sigma_h^2} | h_p^{obs} (x^p_i, y^p_i) - h (x^p_i, y^p_i) |^2, $$ where $\\mathcal{C}^s$ is the misfit between the modeled and observed top ice surface: $$ \\mathcal{C}^s = \\int_{\\Omega} \\frac{1}{2 \\sigma_s^2} \\left| s - s^{obs} \\right|^2,$$ where $\\mathcal{C}^{d}$ is a misfit term between the flux divergence and its polynomial regression $d$ with respect to the ice surface elevation $s(x,y)$ to enforce smoothness with dependence to $s$: $$ \\mathcal{C}^{d} = \\int_{\\Omega} \\frac{1}{2 \\sigma_d^2} \\left| \\nabla \\cdot (h {\\bar{\\bf u}}) - d \\right|^2, $$ where $\\mathcal{R}^h$ is a regularization term to enforce anisotropic smoothness and convexity of $h$: $$ \\mathcal{R}^h = \\alpha_h \\int_{h>0} \\left( | \\nabla h \\cdot \\tilde{{\\bf u}}^{s,obs} |^2 + \\beta | \\nabla h \\cdot (\\tilde{{\\bf u}}^{s,obs})^{\\perp} |^2 - \\gamma h \\right), $$ where $\\mathcal{R}^{\\tilde{A}}$ is a regularization term to enforce smooth A: $$ \\mathcal{R}^{\\tilde{A}} = \\alpha_{\\tilde{A}} \\int_{\\Omega} | \\nabla \\tilde{A} |^2, $$ where $\\mathcal{P}^h$ is a penalty term to enforce nonnegative ice thickness, and zero thickness outside a given mask: $$ \\mathcal{P}^h = 10^{10} \\times \\left( \\int_{h<0} h^2 + \\int_{\\mathcal{M}^{\\rm ice-free}} h^2 \\right).$$ Check at the reference paper given below for more explanation on the regularization terms. Define controls and cost components The above optimization problem is given in the most general case, however, you may select only some components according to your data as follows: the list of control variables you wish to optimize, e.g. params.opti_control=['thk','strflowctrl','usurf'] # this is the most general case params.opti_control=['thk','usurf'] # this will only optimize ice thickness and top surface elevation params.opti_control=['thk'] # this will only optimize ice thickness the list of cost components you wish to minimize, e.g. glacier.config.opti_cost=['velsurf','thk','usurf','divfluxfcz','icemask'] # this is the most general case glacier.config.opti_cost=['velsurf','icemask'] # In this case, you only fit surface velocity and ice mask. Make sure you have a balance between controls and constraints to ensure the problem to have a unique solution. Exploring parameters There are parameters that may need to tune for each application. First, you may change your expected confidence levels (i.e. tolerance to fit the data) $\\sigma^u, \\sigma^h, \\sigma^s, \\sigma^d$ to fit surface ice velocity, ice thickness, surface top elevation, or divergence of the flux as follows: params.opti_velsurfobs_std = 5 # unit m/y params.opti_thkobs_std = 5 # unit m params.opti_usurfobs_std = 5 # unit m params.opti_divfluxobs_std = 1 # unit m/y Second, you may change regularization parameters such as i) $\\alpha^h, \\alpha^A$, which control the regularization weights for the ice thickness and strflowctrl (increasing $\\alpha^h, \\alpha^A$ will make thse fields spatially smoother), or ii) parameters beta and gamma involved for regularizing the ice thickness h. Taking beta=1 occurs to enforce isotropic smoothing, reducing beta will make the smoothing more and more anisotropic to enforce further smoothing along ice flow directions than accross directions (as expected for the topography of a glacier bedrock, which was eroded over long times). Setting parameter gamma to a small value may be usefull to add a bit of convexity in the system. This may help when initializing the inverse modelled with zero thickness, or to treat margin regions with no data available. These parameters may be changed as follows: params.opti_regu_param_thk = 10.0 # weight for the regul. of thk params.opti_regu_param_strflowctrl = 1.0 # weight for the regul. of strflowctrl params.opti_smooth_anisotropy_factor = 0.2 params.opti_convexity_weight = 0.002 Lastly, there are a couple of other parameters we may be interest to change e.g. params.opti_nbitmax = 1000 # Number of it. for the optimization params.opti_step_size = 0.001 # step size in the optimization iterative algorithm params.opti_init_zero_thk = True # Force inializing with zero ice thickness (otherwise take thkinit) Monitoring the optimization You may monitor the data assimilation during the inverse modelling in several ways: Check that the components of the costs decrease over time, the value of cost are printed during the optimization, and a graph is produced at the end. Set up glacier.config.plot_result = True and glacier.config.plt2d_live = True to monitor in live time the evolution of the field your are optimizing such as the ice thickness, the surface ice speeds, ect ... You may also check (hopefully decreasing) STD given in the figure. You may do the same monitoring after the run looking at optimize.nc If you asked divfluxfcz to be in glacier.config.opti_cost, you should check what look like the divergence of the fluc (divflux) Reference @article{IGM-inv, author = \"Jouvet, G.\", title = \"Inversion of a Stokes ice flow model emulated by deep learning\", DOI = \"10.1017/jog.2022.41\", journal = \"Journal of Glaciology\", year = \"2022\", pages = \"1--14\", publisher = \"Cambridge University Press\" }","title":"Optimize v1"},{"location":"modules/optimize_v1/#igm-module-optimize_v1","text":"","title":"IGM module optimize_v1"},{"location":"modules/optimize_v1/#description","text":"A data assimilation module of IGM permits to seek optimal ice thickness, top ice surface, and ice flow parametrization (red variables in the following figure), that best explains observational data such as surface ice speeds, ice thickness profiles, top ice surface (blue variables in the following figure) while being consistent with the ice flow iflo_emulator used in forwrd modelling. This page explains how to use the data assimilation module as a preliminary step in IGM of a forward/prognostic model run. I recommend to read the paper reference given below before to proceed further.","title":"Description:"},{"location":"modules/optimize_v1/#getting-the-data","text":"The first thing you need to do is to get as much data as possible, this includes: Observed surface ice velocities ${\\bf u}^{s,obs}$, e.g. from Millan and al. (2022). Surface top elevation $s^{obs}$, e.g. SRTM, ESA GLO-30, ... Ice thickness profiles $h_p^{obs}$, e.g. GlaThiDa Glacier outlines, and resulting mask, e.g. from the Randolph Glacier Inventory. Of course, you may not have all these data, which is fine. You work with a reduced amount of data, however, you will have make assumptions to reduce the number of variables to optimize (controls) to keep the optimization problem well-posed (i.e., with a unique solution). All the data need to be assemblied in 2D raster grid in an netcdf file (called by default observation.nc) using convention variable names but ending with 'obs'. E.g. observation.nc contains fields 'usurfobs' (observed top surface elevation), 'thkobs' (observed thickness profiles, use nan or novalue where no data is available), 'icemaskobs' (this mask from RGI outline serve to enforce zero ice thickness outside the mask), 'uvelsurfobs' and 'vvelsurfobs' (x- and y- components of the horizontal surface ice velocity, use nan or novalue where no data is available), 'thkinit' (this may be a formerly-inferred ice thickness field to initalize the inverse model, otherwise it would start from thk=0). Use the IGM 'preprare_data' to download all the data you need using OGGM and the GlaThiDa database","title":"Getting the data"},{"location":"modules/optimize_v1/#asumption-on-the-ice-flow-control","text":"Optimizing for both Arrhenius factor (A) and sliding coefficient (c) would lead to multiple solutions as several combinations of the two may explain the observed ice flow similarly. To deal with this issue, we introduce a single control of the ice flow strenght (named as 'strflowctrl' in IGM) $\\tilde{A}$ = A + lambda c, where A is the Arrhenius factor that controls the ice shearing from cold-ice case (low A) to temperate ice case (A=78), c is a sliding coefficient that controls the strength of basal motion from no sliding (c=0) to high sliding (high c) and lambda=1 is a given parameter.","title":"Asumption on the ice flow control"},{"location":"modules/optimize_v1/#general-optimization-setting","text":"The optimization problem consists of finding spatially varying fields ($h$, $\\tilde{A}$, $s$) that minimize the cost function $$ \\mathcal{J}(h,\\tilde{A},s) = \\mathcal{C}^u + \\mathcal{C}^h + \\mathcal{C}^s + \\mathcal{C}^{d} + \\mathcal{R}^h + \\mathcal{R}^{\\tilde{A}} + \\mathcal{P}^h, $$ where $\\mathcal{C}^u$ is the misfit between modeled and observed surface ice velocities ($\\mathcal{F}$ is the output of the ice flow iflo_emulator/neural iflo_network): $$ \\mathcal{C}^u = \\int_{\\Omega} \\frac{1}{2 \\sigma_u^2} \\left| {\\bf u}^{s,obs} - \\mathcal{F}( h, \\frac{\\partial s}{\\partial x}, \\frac{\\partial s}{\\partial y}, \\tilde{A}) \\right|^2, $$ where $\\mathcal{C}^h$ is the misfit between modeled and observed ice thickness profiles: $$ \\mathcal{C}^h = \\sum_{p=1,...,P} \\sum_{i=1,...,M_p} \\frac{1}{2 \\sigma_h^2} | h_p^{obs} (x^p_i, y^p_i) - h (x^p_i, y^p_i) |^2, $$ where $\\mathcal{C}^s$ is the misfit between the modeled and observed top ice surface: $$ \\mathcal{C}^s = \\int_{\\Omega} \\frac{1}{2 \\sigma_s^2} \\left| s - s^{obs} \\right|^2,$$ where $\\mathcal{C}^{d}$ is a misfit term between the flux divergence and its polynomial regression $d$ with respect to the ice surface elevation $s(x,y)$ to enforce smoothness with dependence to $s$: $$ \\mathcal{C}^{d} = \\int_{\\Omega} \\frac{1}{2 \\sigma_d^2} \\left| \\nabla \\cdot (h {\\bar{\\bf u}}) - d \\right|^2, $$ where $\\mathcal{R}^h$ is a regularization term to enforce anisotropic smoothness and convexity of $h$: $$ \\mathcal{R}^h = \\alpha_h \\int_{h>0} \\left( | \\nabla h \\cdot \\tilde{{\\bf u}}^{s,obs} |^2 + \\beta | \\nabla h \\cdot (\\tilde{{\\bf u}}^{s,obs})^{\\perp} |^2 - \\gamma h \\right), $$ where $\\mathcal{R}^{\\tilde{A}}$ is a regularization term to enforce smooth A: $$ \\mathcal{R}^{\\tilde{A}} = \\alpha_{\\tilde{A}} \\int_{\\Omega} | \\nabla \\tilde{A} |^2, $$ where $\\mathcal{P}^h$ is a penalty term to enforce nonnegative ice thickness, and zero thickness outside a given mask: $$ \\mathcal{P}^h = 10^{10} \\times \\left( \\int_{h<0} h^2 + \\int_{\\mathcal{M}^{\\rm ice-free}} h^2 \\right).$$ Check at the reference paper given below for more explanation on the regularization terms.","title":"General optimization setting"},{"location":"modules/optimize_v1/#define-controls-and-cost-components","text":"The above optimization problem is given in the most general case, however, you may select only some components according to your data as follows: the list of control variables you wish to optimize, e.g. params.opti_control=['thk','strflowctrl','usurf'] # this is the most general case params.opti_control=['thk','usurf'] # this will only optimize ice thickness and top surface elevation params.opti_control=['thk'] # this will only optimize ice thickness the list of cost components you wish to minimize, e.g. glacier.config.opti_cost=['velsurf','thk','usurf','divfluxfcz','icemask'] # this is the most general case glacier.config.opti_cost=['velsurf','icemask'] # In this case, you only fit surface velocity and ice mask. Make sure you have a balance between controls and constraints to ensure the problem to have a unique solution.","title":"Define controls and cost components"},{"location":"modules/optimize_v1/#exploring-parameters","text":"There are parameters that may need to tune for each application. First, you may change your expected confidence levels (i.e. tolerance to fit the data) $\\sigma^u, \\sigma^h, \\sigma^s, \\sigma^d$ to fit surface ice velocity, ice thickness, surface top elevation, or divergence of the flux as follows: params.opti_velsurfobs_std = 5 # unit m/y params.opti_thkobs_std = 5 # unit m params.opti_usurfobs_std = 5 # unit m params.opti_divfluxobs_std = 1 # unit m/y Second, you may change regularization parameters such as i) $\\alpha^h, \\alpha^A$, which control the regularization weights for the ice thickness and strflowctrl (increasing $\\alpha^h, \\alpha^A$ will make thse fields spatially smoother), or ii) parameters beta and gamma involved for regularizing the ice thickness h. Taking beta=1 occurs to enforce isotropic smoothing, reducing beta will make the smoothing more and more anisotropic to enforce further smoothing along ice flow directions than accross directions (as expected for the topography of a glacier bedrock, which was eroded over long times). Setting parameter gamma to a small value may be usefull to add a bit of convexity in the system. This may help when initializing the inverse modelled with zero thickness, or to treat margin regions with no data available. These parameters may be changed as follows: params.opti_regu_param_thk = 10.0 # weight for the regul. of thk params.opti_regu_param_strflowctrl = 1.0 # weight for the regul. of strflowctrl params.opti_smooth_anisotropy_factor = 0.2 params.opti_convexity_weight = 0.002 Lastly, there are a couple of other parameters we may be interest to change e.g. params.opti_nbitmax = 1000 # Number of it. for the optimization params.opti_step_size = 0.001 # step size in the optimization iterative algorithm params.opti_init_zero_thk = True # Force inializing with zero ice thickness (otherwise take thkinit)","title":"Exploring parameters"},{"location":"modules/optimize_v1/#monitoring-the-optimization","text":"You may monitor the data assimilation during the inverse modelling in several ways: Check that the components of the costs decrease over time, the value of cost are printed during the optimization, and a graph is produced at the end. Set up glacier.config.plot_result = True and glacier.config.plt2d_live = True to monitor in live time the evolution of the field your are optimizing such as the ice thickness, the surface ice speeds, ect ... You may also check (hopefully decreasing) STD given in the figure. You may do the same monitoring after the run looking at optimize.nc If you asked divfluxfcz to be in glacier.config.opti_cost, you should check what look like the divergence of the fluc (divflux)","title":"Monitoring the optimization"},{"location":"modules/optimize_v1/#reference","text":"@article{IGM-inv, author = \"Jouvet, G.\", title = \"Inversion of a Stokes ice flow model emulated by deep learning\", DOI = \"10.1017/jog.2022.41\", journal = \"Journal of Glaciology\", year = \"2022\", pages = \"1--14\", publisher = \"Cambridge University Press\" }","title":"Reference"},{"location":"modules/particles/","text":"IGM module particles Description: This IGM module implements a particle tracking routine, which computes trajectory of virtual particles advected by the ice flow. The specificity is that it runs in live time during the forward mdodel run and a large number of particles can be computed tanks to the parrallel implementation with TensorFlow. The routine includes particle seeding (by default in the accumulation area at regular intervals, but this can be customized), and tracking (advection by the velocity field in 3D). There is currently no strategy for removing particles, therefore, there is risk of overloading the memory when using this routine as it is for long time and/or with intense seeding. There are currently 2 implementations (switch with parameter part_tracking_method : 'simple' : Horizontal and vertical directions are treated differently: i) In the horizontal plan, particles are advected with the horizontal velocity field (interpolated bi-linearly) ii) In the vertical direction, particles are tracked along the ice column scaled between 0 and 1 (0 at the bed, 1 at the top surface) with the relative position along the ice column. Particles are always initialized at 1 relative height (assumed to be on the surface). The evolution of the particle within the ice column through time is computed according to the surface mass balance: the particle deepens when the surface mass balance is positive (the relative height decreases), and re-emerge when the surface mass balance is negative (the relative height increases). '3d' : requires to activate module vert_flow , which computes the vertical velocity by integrating the divergence of the horizontal velocity. This permits in turn to perform 3D particle tracking. For now, part_tracking_method is by default set to 'simple' , as the '3d' method (and the dependence vert_flow ) needs to further tested. Note that you my adapt the seeding to your need. You may keep the default seeding in the accumulation area setting the seeding frequency with part_frequency_seeding parameter and the seeding density part_density_seeding parameter. Alternatively, you may define your own seeding strategy (e.g. seeding close to rock walls/nunataks). To do so, you may redefine the function seeding_particles() in a file particles.py provided in the working directory (check the example aletsch-1880-2100). When excuted, igm_run will overide the original function seeding_particles() with the new user-defined one. The module needs horizontal velocities (state.U), as well as vertical speeds (state.W) that ice computed with the vert_flow module when part_tracking_method is set to 3d . Note: in the code, positions of particles are recorded within a vector of lenght te number of traked particels state.xpos, state.ypos, state.zpos. Variable state.rhpos provide the relative height within the ice column (1 at the surface, 0 at the bed). At each time step, the weight of surface debris contains in each cell the 2D horizontal grid is computed, and stored in variable state.weight_particles.","title":"particles"},{"location":"modules/particles/#igm-module-particles","text":"","title":"IGM module particles"},{"location":"modules/particles/#description","text":"This IGM module implements a particle tracking routine, which computes trajectory of virtual particles advected by the ice flow. The specificity is that it runs in live time during the forward mdodel run and a large number of particles can be computed tanks to the parrallel implementation with TensorFlow. The routine includes particle seeding (by default in the accumulation area at regular intervals, but this can be customized), and tracking (advection by the velocity field in 3D). There is currently no strategy for removing particles, therefore, there is risk of overloading the memory when using this routine as it is for long time and/or with intense seeding. There are currently 2 implementations (switch with parameter part_tracking_method : 'simple' : Horizontal and vertical directions are treated differently: i) In the horizontal plan, particles are advected with the horizontal velocity field (interpolated bi-linearly) ii) In the vertical direction, particles are tracked along the ice column scaled between 0 and 1 (0 at the bed, 1 at the top surface) with the relative position along the ice column. Particles are always initialized at 1 relative height (assumed to be on the surface). The evolution of the particle within the ice column through time is computed according to the surface mass balance: the particle deepens when the surface mass balance is positive (the relative height decreases), and re-emerge when the surface mass balance is negative (the relative height increases). '3d' : requires to activate module vert_flow , which computes the vertical velocity by integrating the divergence of the horizontal velocity. This permits in turn to perform 3D particle tracking. For now, part_tracking_method is by default set to 'simple' , as the '3d' method (and the dependence vert_flow ) needs to further tested. Note that you my adapt the seeding to your need. You may keep the default seeding in the accumulation area setting the seeding frequency with part_frequency_seeding parameter and the seeding density part_density_seeding parameter. Alternatively, you may define your own seeding strategy (e.g. seeding close to rock walls/nunataks). To do so, you may redefine the function seeding_particles() in a file particles.py provided in the working directory (check the example aletsch-1880-2100). When excuted, igm_run will overide the original function seeding_particles() with the new user-defined one. The module needs horizontal velocities (state.U), as well as vertical speeds (state.W) that ice computed with the vert_flow module when part_tracking_method is set to 3d . Note: in the code, positions of particles are recorded within a vector of lenght te number of traked particels state.xpos, state.ypos, state.zpos. Variable state.rhpos provide the relative height within the ice column (1 at the surface, 0 at the bed). At each time step, the weight of surface debris contains in each cell the 2D horizontal grid is computed, and stored in variable state.weight_particles.","title":"Description:"},{"location":"modules/particles_v1/","text":"IGM module particle_v1 Description: This IGM module implments the former particle tracking routine associated with iceflow_v1 (check at the doc of particles).","title":"Particles v1"},{"location":"modules/particles_v1/#igm-module-particle_v1","text":"","title":"IGM module particle_v1"},{"location":"modules/particles_v1/#description","text":"This IGM module implments the former particle tracking routine associated with iceflow_v1 (check at the doc of particles).","title":"Description:"},{"location":"modules/plot2d/","text":"IGM module plot2d Description: This IGM module produces 2D plan-view plots of variable defined by parameter plt2d_var (e.g. plt2d_var can be set to thk , or ubar , ...). The saving frequency is given by parameter time_save defined in module time . The scale range of the colobar is controlled by parameter plt2d_varmax . By default, the plots are saved as png files in the working directory. However, one may display the plot \"in live\" by setting plt2d_live to True. Note that if you use the spyder python editor, you need to turn plt2d_editor to 'sp'. If the particles module is activated, one may plot particles on the top setting plt2d_particles to True, or remove them form the plot seeting it to False.","title":"plot2d"},{"location":"modules/plot2d/#igm-module-plot2d","text":"","title":"IGM module plot2d"},{"location":"modules/plot2d/#description","text":"This IGM module produces 2D plan-view plots of variable defined by parameter plt2d_var (e.g. plt2d_var can be set to thk , or ubar , ...). The saving frequency is given by parameter time_save defined in module time . The scale range of the colobar is controlled by parameter plt2d_varmax . By default, the plots are saved as png files in the working directory. However, one may display the plot \"in live\" by setting plt2d_live to True. Note that if you use the spyder python editor, you need to turn plt2d_editor to 'sp'. If the particles module is activated, one may plot particles on the top setting plt2d_particles to True, or remove them form the plot seeting it to False.","title":"Description:"},{"location":"modules/pretraining/","text":"IGM module pretaining Description: This module performs a pretraining of the ice flow iflo_emulator on a glacier catalogue to improve the performance of the emaulator when used in glacier forward run. The pretraining can be relatively computationally demanding task (a couple of hours). This module should be called alone independently of any other igm module. Here is an example of paramter file: { \"modules_preproc\": [\"pretraining\"], \"modules_process\": [], \"modules_postproc\": [], \"data_dir\": \"surflib3d_shape_100\", \"iflo_solve_nbitmax\": 2000, \"iflo_solve_stop_if_no_decrease\": false, \"iflo_retrain_emulator_lr\": 0.0001, \"iflo_dim_arrhenius\": 3, \"soft_begining\": 500 } To run it, one first needs to have available a glacier catalogue. I provide here a dataset of a glacier catalogue (mountain glaciers) I have mostly used for pretraining IGM emaulators. Once downloaded (or self generated), the folder \"surflib3d_shape_100\" can be re-organized into a subfolder \"train\" and a subfolder \"test\" as follows: \u251c\u2500\u2500 test \u2502 \u2514\u2500\u2500 NZ000_A78_C0 \u2514\u2500\u2500 train \u251c\u2500\u2500 ALP02_A78_C0 \u251c\u2500\u2500 ALP03_A78_C0 \u251c\u2500\u2500 ALP04_A78_C0 \u251c\u2500\u2500 ALP05_A78_C0 \u251c\u2500\u2500 ALP06_A78_C0 \u251c\u2500\u2500 ALP11_A78_C0 \u251c\u2500\u2500 ALP17_A78_C0 The path (or name of the data folder) must be pass in parameter data_dir .","title":"pretraining"},{"location":"modules/pretraining/#igm-module-pretaining","text":"","title":"IGM module pretaining"},{"location":"modules/pretraining/#description","text":"This module performs a pretraining of the ice flow iflo_emulator on a glacier catalogue to improve the performance of the emaulator when used in glacier forward run. The pretraining can be relatively computationally demanding task (a couple of hours). This module should be called alone independently of any other igm module. Here is an example of paramter file: { \"modules_preproc\": [\"pretraining\"], \"modules_process\": [], \"modules_postproc\": [], \"data_dir\": \"surflib3d_shape_100\", \"iflo_solve_nbitmax\": 2000, \"iflo_solve_stop_if_no_decrease\": false, \"iflo_retrain_emulator_lr\": 0.0001, \"iflo_dim_arrhenius\": 3, \"soft_begining\": 500 } To run it, one first needs to have available a glacier catalogue. I provide here a dataset of a glacier catalogue (mountain glaciers) I have mostly used for pretraining IGM emaulators. Once downloaded (or self generated), the folder \"surflib3d_shape_100\" can be re-organized into a subfolder \"train\" and a subfolder \"test\" as follows: \u251c\u2500\u2500 test \u2502 \u2514\u2500\u2500 NZ000_A78_C0 \u2514\u2500\u2500 train \u251c\u2500\u2500 ALP02_A78_C0 \u251c\u2500\u2500 ALP03_A78_C0 \u251c\u2500\u2500 ALP04_A78_C0 \u251c\u2500\u2500 ALP05_A78_C0 \u251c\u2500\u2500 ALP06_A78_C0 \u251c\u2500\u2500 ALP11_A78_C0 \u251c\u2500\u2500 ALP17_A78_C0 The path (or name of the data folder) must be pass in parameter data_dir .","title":"Description:"},{"location":"modules/print_comp/","text":"IGM module print_comp Description: This module reports the computational times taken by any IGM modules at the end of the model run directly in the terminal output, as well as in a file (\"computational-statistics.txt\"). It also produces a camember-like plot ( \"computational-pie.png\") displaying the relative importance of each module, computationally-wise. Note: These numbers must be interepreted with care: Leaks of computational times from one to another module are sometime observed (likely) due to asynchronous GPU calculations.","title":"print_comp"},{"location":"modules/print_comp/#igm-module-print_comp","text":"","title":"IGM module print_comp"},{"location":"modules/print_comp/#description","text":"This module reports the computational times taken by any IGM modules at the end of the model run directly in the terminal output, as well as in a file (\"computational-statistics.txt\"). It also produces a camember-like plot ( \"computational-pie.png\") displaying the relative importance of each module, computationally-wise. Note: These numbers must be interepreted with care: Leaks of computational times from one to another module are sometime observed (likely) due to asynchronous GPU calculations.","title":"Description:"},{"location":"modules/print_info/","text":"IGM module print_info Description: This IGM modules prints in the terminal basic live-time modelling informations such that the iteration number, time, time step, and ice volume (km^3).","title":"print_info"},{"location":"modules/print_info/#igm-module-print_info","text":"","title":"IGM module print_info"},{"location":"modules/print_info/#description","text":"This IGM modules prints in the terminal basic live-time modelling informations such that the iteration number, time, time step, and ice volume (km^3).","title":"Description:"},{"location":"modules/read_output/","text":"IGM read_output Description: This IGM module permits to read an output NetCDF file produced previously and to run igm as if these quantities were shortly computed, this is mainly usefull for testing postprocessing module independently.","title":"Read output"},{"location":"modules/read_output/#igm-read_output","text":"","title":"IGM read_output"},{"location":"modules/read_output/#description","text":"This IGM module permits to read an output NetCDF file produced previously and to run igm as if these quantities were shortly computed, this is mainly usefull for testing postprocessing module independently.","title":"Description:"},{"location":"modules/rockflow/","text":"IGM module rockflow Description: This module extends the ice flow outside the glaciated area, by giving a constant speed and along-slope flow direction. This modules serves to track rock-like particles (with module particles ) everywhere in ice-free and ice-filled areas, particles being either advected at constant steep (controlled by parameter rock_flow_speed ) following the stepest gradient of the ice-free terrain in 2D, or by ice flow in 3D.","title":"rockflow"},{"location":"modules/rockflow/#igm-module-rockflow","text":"","title":"IGM module rockflow"},{"location":"modules/rockflow/#description","text":"This module extends the ice flow outside the glaciated area, by giving a constant speed and along-slope flow direction. This modules serves to track rock-like particles (with module particles ) everywhere in ice-free and ice-filled areas, particles being either advected at constant steep (controlled by parameter rock_flow_speed ) following the stepest gradient of the ice-free terrain in 2D, or by ice flow in 3D.","title":"Description:"},{"location":"modules/smb_oggm/","text":"IGM smb_oggm module Description: Module smb_oggm implements the monthly temperature index model calibrated on geodetic MB data (Hugonnet, 2021) by OGGM. The yearly surface mass balance is computed with $$ SMB = \\frac{\\rho_w}{\\rho_i} \\sum_{i=1}^{12} \\left( P_i^{sol} - d_f \\max { T_i - T_{melt}, 0 } \\right), $$ where $P_i^{sol}$ is the is the monthly solid precipitation, $T_i$ is the monthly temperature and $T_{melt}$ is the air temperature above which ice melt is assumed to occur (parameter temp_melt ), $d_f$ is the melt factor (parameter melt_f ), and $\\frac{\\rho_w}{\\rho_i} $ is the ratio of water to ice density. Solid precipitation $P_i^{sol}$ is computed out of precipitation and temperature such that it equals precipitation when the temperature is lower than a certain threshold (parameter temp_all_solid ), zero above another threshold (parameter temp_all_liq ), with a linear transition between the two. Module oggm_shop provides all calibrated parameters.","title":"smb_oggm"},{"location":"modules/smb_oggm/#igm-smb_oggm-module","text":"","title":"IGM smb_oggm module"},{"location":"modules/smb_oggm/#description","text":"Module smb_oggm implements the monthly temperature index model calibrated on geodetic MB data (Hugonnet, 2021) by OGGM. The yearly surface mass balance is computed with $$ SMB = \\frac{\\rho_w}{\\rho_i} \\sum_{i=1}^{12} \\left( P_i^{sol} - d_f \\max { T_i - T_{melt}, 0 } \\right), $$ where $P_i^{sol}$ is the is the monthly solid precipitation, $T_i$ is the monthly temperature and $T_{melt}$ is the air temperature above which ice melt is assumed to occur (parameter temp_melt ), $d_f$ is the melt factor (parameter melt_f ), and $\\frac{\\rho_w}{\\rho_i} $ is the ratio of water to ice density. Solid precipitation $P_i^{sol}$ is computed out of precipitation and temperature such that it equals precipitation when the temperature is lower than a certain threshold (parameter temp_all_solid ), zero above another threshold (parameter temp_all_liq ), with a linear transition between the two. Module oggm_shop provides all calibrated parameters.","title":"Description:"},{"location":"modules/smb_simple/","text":"IGM module smb_simple Description: This IGM modules models a simple surface mass balance model parametrized by time-evolving ELA $z_{ELA}$, ablation $\\beta_{abl}$ and accumulation $\\beta_{acc}$ gradients, and max accumulation $m_{acc}$ parameters: $$SMB(z)=min(\\beta_{acc} (z-z_{ELA}),m_{acc})\\quad\\textrm{if}\\;z>z_{ELA},$$ $$SMB(z)=\\beta_{abl} (z-z_{ELA})\\quad\\textrm{else}.$$ These parameters may be given in file (file name given in smb_simple_file parameter), which look like this time gradabl gradacc ela accmax 1900 0.009 0.005 2800 2.0 2000 0.009 0.005 2900 2.0 2100 0.009 0.005 3300 2.0 or directly as parameter in the cconfig params.json file: \"smb_simple_array\": [ [\"time\", \"gradabl\", \"gradacc\", \"ela\", \"accmax\"], [ 1900, 0.009, 0.005, 2800, 2.0], [ 2000, 0.009, 0.005, 2900, 2.0], [ 2100, 0.009, 0.005, 3300, 2.0] ], If parameter smb_simple_array is set to empty list [] , then it will read the file smb_simple_file , otherwise it read the array smb_simple_array (which is here in fact a list of list). The module will compute surface mass balance at a frequency given by parameter smb_simple_update_freq (default is 1 year), and interpolate linearly the 4 parameters in time. If one has provided in input an \"icemask\" field, then this module will compute negative surface mass balance (-10 m/y) in place where posstive surface mass balance outside the mask were originally computed. The goal here is to prevent against overflowing in neibourghing catchements.","title":"Smb simple"},{"location":"modules/smb_simple/#igm-module-smb_simple","text":"","title":"IGM module smb_simple"},{"location":"modules/smb_simple/#description","text":"This IGM modules models a simple surface mass balance model parametrized by time-evolving ELA $z_{ELA}$, ablation $\\beta_{abl}$ and accumulation $\\beta_{acc}$ gradients, and max accumulation $m_{acc}$ parameters: $$SMB(z)=min(\\beta_{acc} (z-z_{ELA}),m_{acc})\\quad\\textrm{if}\\;z>z_{ELA},$$ $$SMB(z)=\\beta_{abl} (z-z_{ELA})\\quad\\textrm{else}.$$ These parameters may be given in file (file name given in smb_simple_file parameter), which look like this time gradabl gradacc ela accmax 1900 0.009 0.005 2800 2.0 2000 0.009 0.005 2900 2.0 2100 0.009 0.005 3300 2.0 or directly as parameter in the cconfig params.json file: \"smb_simple_array\": [ [\"time\", \"gradabl\", \"gradacc\", \"ela\", \"accmax\"], [ 1900, 0.009, 0.005, 2800, 2.0], [ 2000, 0.009, 0.005, 2900, 2.0], [ 2100, 0.009, 0.005, 3300, 2.0] ], If parameter smb_simple_array is set to empty list [] , then it will read the file smb_simple_file , otherwise it read the array smb_simple_array (which is here in fact a list of list). The module will compute surface mass balance at a frequency given by parameter smb_simple_update_freq (default is 1 year), and interpolate linearly the 4 parameters in time. If one has provided in input an \"icemask\" field, then this module will compute negative surface mass balance (-10 m/y) in place where posstive surface mass balance outside the mask were originally computed. The goal here is to prevent against overflowing in neibourghing catchements.","title":"Description:"},{"location":"modules/thk/","text":"IGM module thk Description: This IGM module solves the mass conservation of ice to update the thickness from ice flow (computed from module iceflow ) and surface mass balance (given any module that update smb ). The mass conservation equation is solved using an explicit first-order upwind finite-volume scheme on the 2D working grid. With this scheme mass of ice is allowed to move from cell to cell (where thickness and velocities are defined) from edge-defined fluxes (inferred from depth-averaged velocities, and ice thickness in upwind direction). The resulting scheme is mass conservative and parallelizable (because fully explicit). However, it is subject to a CFL condition. This means that the time step (defined in module time ) is controlled by parameter parameter time_cfl , which is the maximum number of cells crossed in one iteration (this parameter cannot exceed one), see the documentation of module time . A bit more details on the scheme are given in the following paper. @article{jouvet2022deep, author = {Jouvet, Guillaume and Cordonnier, Guillaume and Kim, Byungsoo and L{\\\"u}thi, Martin and Vieli, Andreas and Aschwanden, Andy}, journal = {Journal of Glaciology}, number = {270}, pages = {651--664}, publisher = {Cambridge University Press}, title = {Deep learning speeds up ice flow modelling by several orders of magnitude}, volume = {68}, year = {2022}, doi = {10.1017/jog.2021.120}, }","title":"thk"},{"location":"modules/thk/#igm-module-thk","text":"","title":"IGM module thk"},{"location":"modules/thk/#description","text":"This IGM module solves the mass conservation of ice to update the thickness from ice flow (computed from module iceflow ) and surface mass balance (given any module that update smb ). The mass conservation equation is solved using an explicit first-order upwind finite-volume scheme on the 2D working grid. With this scheme mass of ice is allowed to move from cell to cell (where thickness and velocities are defined) from edge-defined fluxes (inferred from depth-averaged velocities, and ice thickness in upwind direction). The resulting scheme is mass conservative and parallelizable (because fully explicit). However, it is subject to a CFL condition. This means that the time step (defined in module time ) is controlled by parameter parameter time_cfl , which is the maximum number of cells crossed in one iteration (this parameter cannot exceed one), see the documentation of module time . A bit more details on the scheme are given in the following paper. @article{jouvet2022deep, author = {Jouvet, Guillaume and Cordonnier, Guillaume and Kim, Byungsoo and L{\\\"u}thi, Martin and Vieli, Andreas and Aschwanden, Andy}, journal = {Journal of Glaciology}, number = {270}, pages = {651--664}, publisher = {Cambridge University Press}, title = {Deep learning speeds up ice flow modelling by several orders of magnitude}, volume = {68}, year = {2022}, doi = {10.1017/jog.2021.120}, }","title":"Description:"},{"location":"modules/time/","text":"IGM module time Description: This IGM modules computes time step such that i) it satisfy the CFL condition (controlled by parameter clf ) ii) it is lower than a given maximum time step (controlled by parameter time_step_max ) iii) it hits exactly given saving times (controlled by parameter time_save ). The module additionally updates the time $t$ in addition to the time step. Indeed, for stability reasons of the transport scheme for the ice thickness evolution, the time step must respect a CFL condition, controlled by parameter time_cfl , which is the maximum number of cells crossed in one iteration (this parameter cannot exceed one). By default, we take time_cfl to 0.3. We additionally request time step to be upper-bounded by a user-defined parameter time_save (default: 1 year). Among the parameters of this module time_start and time_end defines the simulation starting and ending times, while time_save defines the frequency at which results must be saved (default: 10 years). A bit more details on the time step stability conditionsis given in the following paper. @article{jouvet2022deep, author = {Jouvet, Guillaume and Cordonnier, Guillaume and Kim, Byungsoo and L{\\\"u}thi, Martin and Vieli, Andreas and Aschwanden, Andy}, journal = {Journal of Glaciology}, number = {270}, pages = {651--664}, publisher = {Cambridge University Press}, title = {Deep learning speeds up ice flow modelling by several orders of magnitude}, volume = {68}, year = {2022}, doi = {10.1017/jog.2021.120}, }","title":"time"},{"location":"modules/time/#igm-module-time","text":"","title":"IGM module time"},{"location":"modules/time/#description","text":"This IGM modules computes time step such that i) it satisfy the CFL condition (controlled by parameter clf ) ii) it is lower than a given maximum time step (controlled by parameter time_step_max ) iii) it hits exactly given saving times (controlled by parameter time_save ). The module additionally updates the time $t$ in addition to the time step. Indeed, for stability reasons of the transport scheme for the ice thickness evolution, the time step must respect a CFL condition, controlled by parameter time_cfl , which is the maximum number of cells crossed in one iteration (this parameter cannot exceed one). By default, we take time_cfl to 0.3. We additionally request time step to be upper-bounded by a user-defined parameter time_save (default: 1 year). Among the parameters of this module time_start and time_end defines the simulation starting and ending times, while time_save defines the frequency at which results must be saved (default: 10 years). A bit more details on the time step stability conditionsis given in the following paper. @article{jouvet2022deep, author = {Jouvet, Guillaume and Cordonnier, Guillaume and Kim, Byungsoo and L{\\\"u}thi, Martin and Vieli, Andreas and Aschwanden, Andy}, journal = {Journal of Glaciology}, number = {270}, pages = {651--664}, publisher = {Cambridge University Press}, title = {Deep learning speeds up ice flow modelling by several orders of magnitude}, volume = {68}, year = {2022}, doi = {10.1017/jog.2021.120}, }","title":"Description:"},{"location":"modules/vert_flow/","text":"IGM module vert_flow Description: This IGM module computes the vertical component (providing state.W) of the velocity from the horizontal components (state.U, computed from an emulation of the Blatter-Pattyn model in the module iceflow ) by integrating the imcompressibility condition. This module is typically needed prior calling module particle for 3D particle trajectory integration, or module enthalpy for computing 3D advection-diffusion of the enthalpy.","title":"vert_flow"},{"location":"modules/vert_flow/#igm-module-vert_flow","text":"","title":"IGM module vert_flow"},{"location":"modules/vert_flow/#description","text":"This IGM module computes the vertical component (providing state.W) of the velocity from the horizontal components (state.U, computed from an emulation of the Blatter-Pattyn model in the module iceflow ) by integrating the imcompressibility condition. This module is typically needed prior calling module particle for 3D particle trajectory integration, or module enthalpy for computing 3D advection-diffusion of the enthalpy.","title":"Description:"},{"location":"modules/write_ncdf/","text":"IGM module write_ncdf Description: This IGM module writes 2D field variables defined in the paramer list wncd_vars_to_save into the NetCDF output file given by parameter wncd_output_file (default output.nc). The saving frequency is given by parameter time_save defined in module time .","title":"write_ncdf"},{"location":"modules/write_ncdf/#igm-module-write_ncdf","text":"","title":"IGM module write_ncdf"},{"location":"modules/write_ncdf/#description","text":"This IGM module writes 2D field variables defined in the paramer list wncd_vars_to_save into the NetCDF output file given by parameter wncd_output_file (default output.nc). The saving frequency is given by parameter time_save defined in module time .","title":"Description:"},{"location":"modules/write_particles/","text":"IGM module write_particles Description: This IGM module writes particle time-position in csv files computed by module particles . The saving frequency is given by parameter time_save defined in module time . The data are stored in folder 'trajectory' (created if does not exist). Files 'traj-TIME.csv' reports the space-time position of the particles at time TIME with the following structure: ID, state.xpos, state.ypos, state.zpos, state.rhpos, state.tpos, state.englt X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, providing in turn the particle ID, x,y,z positions, the relative height within the ice column, the seeding time, and the englacial time.","title":"write_particles"},{"location":"modules/write_particles/#igm-module-write_particles","text":"","title":"IGM module write_particles"},{"location":"modules/write_particles/#description","text":"This IGM module writes particle time-position in csv files computed by module particles . The saving frequency is given by parameter time_save defined in module time . The data are stored in folder 'trajectory' (created if does not exist). Files 'traj-TIME.csv' reports the space-time position of the particles at time TIME with the following structure: ID, state.xpos, state.ypos, state.zpos, state.rhpos, state.tpos, state.englt X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, providing in turn the particle ID, x,y,z positions, the relative height within the ice column, the seeding time, and the englacial time.","title":"Description:"},{"location":"modules/write_tif/","text":"IGM module write_tif Description: This IGM module writes 2D field variables defined in the paramer list wtif_vars_to_save into tif output files. Files will be created with names composed by the variable name and the time (e.g., thk-000040.tif, usurf-000090.tif) in the working directory. The saving frequency is given by parameter time_save defined in module time . If input file were call with module load_tif , then the tif meta information are saved, and provided with the final tiff files. This module depends on the rasterio library.","title":"write_tif"},{"location":"modules/write_tif/#igm-module-write_tif","text":"","title":"IGM module write_tif"},{"location":"modules/write_tif/#description","text":"This IGM module writes 2D field variables defined in the paramer list wtif_vars_to_save into tif output files. Files will be created with names composed by the variable name and the time (e.g., thk-000040.tif, usurf-000090.tif) in the working directory. The saving frequency is given by parameter time_save defined in module time . If input file were call with module load_tif , then the tif meta information are saved, and provided with the final tiff files. This module depends on the rasterio library.","title":"Description:"},{"location":"modules/write_ts/","text":"IGM module write_ts Description: This IGM module writes time serie variables (ice glaciated area and volume) into the NetCDF output file defined by parameter wts_output_file (default output_ts.nc). The saving frequency is given by parameter time_save defined in module time .","title":"write_ts"},{"location":"modules/write_ts/#igm-module-write_ts","text":"","title":"IGM module write_ts"},{"location":"modules/write_ts/#description","text":"This IGM module writes time serie variables (ice glaciated area and volume) into the NetCDF output file defined by parameter wts_output_file (default output_ts.nc). The saving frequency is given by parameter time_save defined in module time .","title":"Description:"}]}